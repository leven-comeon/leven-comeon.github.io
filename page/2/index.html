
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leven || Leven の Blog</title>
    <meta name="author" content="leven">
    <meta name="description" content="Hi, here is main page of leven ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/头像.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/full-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 7.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Leven</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>主页</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>文章</span>
        </a>
        
        <a href="/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>类别</span>
        </a>
        
        <a href="/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>标签</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>关于</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Leven</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">主页</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">文章</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">类别</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">标签</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">关于</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Leven</h1>
                <h3>Leven の Blog</h3>
                <h5>Hi, here is main page of leven</h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2024/05/07/6.s081/syscall/">
        <h2>
            Lab 2: system calls
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/MIT">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                MIT
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/5/7
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Lab-2-system-calls"><a href="#Lab-2-system-calls" class="headerlink" title="Lab 2: system calls"></a>Lab 2: system calls</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>将<code>xv6</code> 代码切换到<code>syscall</code> 分支并初始化</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout syscall</span><br><span class="line">$ make clean</span><br></pre></td></tr></tbody></table></figure>

<h2 id="一、trace-系统调用（难度：moderate）"><a href="#一、trace-系统调用（难度：moderate）" class="headerlink" title="一、trace 系统调用（难度：moderate）"></a>一、trace 系统调用（难度：moderate）</h2><blockquote>
<p>添加一个trace system call调用，可以实现跟踪system call。此函数入参为一个数字，可以控制跟踪哪些system call。如：</p>
<p><code>trace(1&lt;&lt;SYS_fork)，trace(10b)，trace(2)</code> 表示跟踪fork调用；</p>
<p><code>trace(1&lt;&lt;SYS_read)，trace(10 0000b)，trace(32)</code> 表示跟踪read调用；</p>
<p><code>trace(10 0010b)，trace(34)</code> 表示跟踪fork、read调用；</p>
</blockquote>
<h3 id="1、系统调用流程"><a href="#1、系统调用流程" class="headerlink" title="1、系统调用流程"></a>1、系统调用流程</h3><p>用户态中：</p>
<ul>
<li>在<code>user/user.h</code> 做函数声明</li>
<li><code>Makefile</code> 调用<code>usys.pl（perl脚本）</code> 生成<code>usys.S</code> ，里面写了具体实现，通过<code>ecall</code> 进入 kernel，通过设置寄存器<code>a7</code> 的值，表明调用哪个system call</li>
<li><code>ecall</code> 执行后存储用户态上下文信息到进程的<code>trapframe</code> 结构体中，并加载内核态页表、寄存器等信息</li>
</ul>
<p>内核态中：</p>
<ul>
<li>开始执行<code>syscall</code> 函数，通过读取<code>trapframe</code> 中<code>a7</code> 寄存器的值，判断系统调用类型</li>
<li>通过函数指针执行对应内核函数，实现系统调用功能</li>
</ul>
<h3 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a>2、具体实现</h3><ul>
<li>在<code>user/user.h</code> 中申明<code>sys_trace</code> 函数<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trace</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li>
<li>在<code>user/usys.pl</code> 中定义函数 entry<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">entry</span>(<span class="string">"trace"</span>);</span><br></pre></td></tr></tbody></table></figure></li>
<li>在<code>Makefile</code> 中添加<code>$U/_trace</code> </li>
<li>在<code>kernel/syscall.h</code> 中添加系统调用号宏定义<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace 22</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>在<code>kernel/proc.h</code> 的<code>proc</code> 结构体中增加<code>mask</code> 数组<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">procstate</span> state; <span class="comment">// Process state</span></span><br><span class="line">    <span class="type">void</span> *chan;           <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">    <span class="type">int</span> killed;           <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">    <span class="type">int</span> xstate;           <span class="comment">// Exit status to be returned to parent's wait</span></span><br><span class="line">    <span class="type">int</span> pid;              <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *parent; <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">    uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">    uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">    <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">trapframe</span> *trapframe; <span class="comment">// data page for trampoline.S</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">context</span> context;      <span class="comment">// swtch() here to run process</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> *ofile[NOFILE];  <span class="comment">// Open files</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">inode</span> *cwd;           <span class="comment">// Current directory</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">    <span class="type">char</span> mask[<span class="number">32</span>];               <span class="comment">// Trace mask</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li>
<li>在<code>kernel/sysproc.c</code> 新增函数<code>sys_trace</code> ，将系统调用号存入到<code>proc</code> 结构体的<code>mask</code> 数组中<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">argint</span>(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">    <span class="type">char</span> *mask = p-&gt;mask;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; i &lt; <span class="number">32</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>)</span><br><span class="line">        {</span><br><span class="line">            mask[i++] = <span class="string">'1'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            mask[i++] = <span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>在<code>kernel/syscall.c</code> 中引入<code>sys_trace</code> 函数申明，并与系统调用号进行关联<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 (*syscalls[])(void) 中添加以下内容</span></span><br><span class="line">[SYS_trace] sys_trace,</span><br></pre></td></tr></tbody></table></figure></li>
<li>在<code>kernel/syscall.c</code> 中新建一个数组存放<code>system_call</code> 的名称<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *syscall_names[<span class="number">32</span>] = {<span class="string">""</span>, <span class="string">"fork"</span>, <span class="string">"exit"</span>, <span class="string">"wait"</span>, <span class="string">"pipe"</span>, <span class="string">"read"</span>, <span class="string">"kill"</span>, <span class="string">"exec"</span>, <span class="string">"fstat"</span>, <span class="string">"chdir"</span>, <span class="string">"dup"</span>, <span class="string">"getpid"</span>, <span class="string">"sbrk"</span>, <span class="string">"sleep"</span>, <span class="string">"uptime"</span>, <span class="string">"open"</span>, <span class="string">"write"</span>, <span class="string">"mknod"</span>, <span class="string">"unlink"</span>, <span class="string">"link"</span>, <span class="string">"mkdir"</span>, <span class="string">"close"</span>, <span class="string">"trace"</span>};</span><br></pre></td></tr></tbody></table></figure></li>
<li>在<code>kernel/syscall.c</code> 的<code>syscall</code> 函数中实现具体的跟踪功能，即判断当前系统调用号是否在需要跟踪的<code>mask</code> 中<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">syscall</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">    num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="built_in">NELEM</span>(syscalls) &amp;&amp; syscalls[num])</span><br><span class="line">    {</span><br><span class="line">        p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">        <span class="comment">// trace begin</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(p-&gt;mask) &gt; <span class="number">0</span> &amp;&amp; p-&gt;mask[num] == <span class="string">'1'</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d: syscall %s -&gt; %d\n"</span>, p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// trace end</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %s: unknown sys call %d\n"</span>,</span><br><span class="line">               p-&gt;pid, p-&gt;name, num);</span><br><span class="line">        p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>在<code>kernel/proc.c</code> 的<code>fork</code> 函数中实现自动复制父进程的<code>mask</code> <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">uvmcopy</span>(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">freeproc</span>(np);</span><br><span class="line">    <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line">np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy mask from parent to child</span></span><br><span class="line"><span class="built_in">safestrcpy</span>(np-&gt;mask, p-&gt;mask, <span class="built_in">sizeof</span>(p-&gt;mask));</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy saved user registers.</span></span><br><span class="line">*(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="二、sysinfo-系统调用（难度：moderate）"><a href="#二、sysinfo-系统调用（难度：moderate）" class="headerlink" title="二、sysinfo 系统调用（难度：moderate）"></a>二、sysinfo 系统调用（难度：moderate）</h2><blockquote>
<p>添加一个 sysinfo system call 调用，可以实现打印可用空间(字节)、可用进程数。</p>
</blockquote>
<h3 id="1、具体实现"><a href="#1、具体实现" class="headerlink" title="1、具体实现"></a>1、具体实现</h3><ul>
<li>在<code>user/user.h</code> 中申明<code>sysinfo</code> 结构体并申明<code>sys_sysinfo</code> 函数<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sysinfo</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li>
<li>在<code>user/usys.pl</code> 中定义函数 entry<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">entry</span>(<span class="string">"sysinfo"</span>);</span><br></pre></td></tr></tbody></table></figure></li>
<li>在<code>Makefile</code> 中添加<code>$U/_sysinfotest</code> </li>
<li>在<code>kernel/syscall.h</code> 中添加系统调用号宏定义<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sysinfo 23</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>在<code>kernel/kalloc.c</code> 新增函数<code>freemem_size</code> 用来统计可用空间大小<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">freemem_size</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (r = kmem.freelist; r; r = r-&gt;next)</span><br><span class="line">    {</span><br><span class="line">        num++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> num * PGSIZE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>在<code>kernel/proc.c</code> 新增函数<code>proc_num</code> 用来统计可用进程数<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">proc_num</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line">    uint64 num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state != UNUSED)</span><br><span class="line">            num++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>在<code>kernel/defs.h</code> 中申明上面添加的两个函数<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">kalloc</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kfree</span><span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kinit</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">freemem_size</span><span class="params">(<span class="type">void</span>)</span></span>;     <span class="comment">// 新增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// proc.c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cpuid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exit</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">growproc</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc_mapstacks</span><span class="params">(<span class="type">pagetable_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">pagetable_t</span> <span class="title">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span>, uint64)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cpu</span> *<span class="built_in">mycpu</span>(<span class="type">void</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cpu</span> *<span class="built_in">getmycpu</span>(<span class="type">void</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span> *<span class="built_in">myproc</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">procinit</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scheduler</span><span class="params">(<span class="type">void</span>)</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sched</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">(<span class="type">void</span> *, <span class="keyword">struct</span> spinlock *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">userinit</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wait</span><span class="params">(uint64)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wakeup</span><span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yield</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">either_copyout</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">void</span> *src, uint64 len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">either_copyin</span><span class="params">(<span class="type">void</span> *dst, <span class="type">int</span> user_src, uint64 src, uint64 len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">procdump</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">proc_num</span><span class="params">(<span class="type">void</span>)</span></span>;     <span class="comment">// 新增</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>在<code>kernel/sysproc.c</code> 引入<code>sysinfo.h</code> ，并新增函数<code>sys_sysinfo</code> ，调用上面的两个函数并将结果封装到<code>sysinfo</code> 结构体中，使用<code>copyout</code> 函数将结构体传回用户态<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"sysinfo.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">uint64 <span class="title">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    uint64 addr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sysinfo</span> info;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">argaddr</span>(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    info.freemem = <span class="built_in">freemem_size</span>();</span><br><span class="line">    info.nproc = <span class="built_in">proc_num</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">copyout</span>(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;info, <span class="built_in">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>在<code>kernel/syscall.c</code> 中引入<code>sys_sysinfo</code> 函数申明，并与系统调用号进行关联<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 (*syscalls[])(void) 中添加以下内容</span></span><br><span class="line">[SYS_sysinfo] sys_sysinfo,</span><br></pre></td></tr></tbody></table></figure></li>
<li>在<code>kernel/syscall.c</code> 的<code>system_call</code> 中加入<code>sysinfo</code> <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *syscall_names[<span class="number">32</span>] = {<span class="string">""</span>, <span class="string">"fork"</span>, <span class="string">"exit"</span>, <span class="string">"wait"</span>, <span class="string">"pipe"</span>, <span class="string">"read"</span>, <span class="string">"kill"</span>, <span class="string">"exec"</span>, <span class="string">"fstat"</span>, <span class="string">"chdir"</span>, <span class="string">"dup"</span>, <span class="string">"getpid"</span>, <span class="string">"sbrk"</span>, <span class="string">"sleep"</span>, <span class="string">"uptime"</span>, <span class="string">"open"</span>, <span class="string">"write"</span>, <span class="string">"mknod"</span>, <span class="string">"unlink"</span>, <span class="string">"link"</span>, <span class="string">"mkdir"</span>, <span class="string">"close"</span>, <span class="string">"trace"</span>, <span class="string">"sysinfo"</span>};</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://raw.githubusercontent.com/leven-comeon/picture-club/main/202405071346710.png"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/operating-system" style=color:#00bcd4>
                operating system
            </a>
        </span>
        
    </div>

    <a href="/2024/05/07/6.s081/syscall/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/05/06/6.s081/utils/">
        <h2>
            Lab 1: Xv6 and Unix utilities
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/MIT">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                MIT
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/5/6
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Lab-1-Xv6-and-Unix-utilities"><a href="#Lab-1-Xv6-and-Unix-utilities" class="headerlink" title="Lab 1: Xv6 and Unix utilities"></a>Lab 1: Xv6 and Unix utilities</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul>
<li>机器OS: <code>ubuntu 20.04</code></li>
<li>安装实验相关包:<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu </span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="一、启动-xv6（难度：easy）"><a href="#一、启动-xv6（难度：easy）" class="headerlink" title="一、启动 xv6（难度：easy）"></a>一、启动 xv6（难度：easy）</h2><ul>
<li><p>克隆<code>xv6</code> 代码并切换到<code>util</code> 分支</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021</span><br><span class="line">Cloning into <span class="string">'xv6-labs-2021'</span>...</span><br><span class="line">...</span><br><span class="line">$ <span class="built_in">cd</span> xv6-labs-2021</span><br><span class="line">$ git checkout util</span><br><span class="line">Branch <span class="string">'util'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'util'</span> from <span class="string">'origin'</span>.</span><br><span class="line">Switched to a new branch <span class="string">'util'</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>构建并运行xv6</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">riscv64-unknown-elf-gcc    -c -o kernel/entry.o kernel/entry.S</span><br><span class="line">riscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie   -c -o kernel/start.o kernel/start.c</span><br><span class="line">...  </span><br><span class="line">riscv64-unknown-elf-ld -z max-page-size=4096 -N -e main -Ttext 0 -o user/_zombie user/zombie.o user/ulib.o user/usys.o user/printf.o user/umalloc.o</span><br><span class="line">riscv64-unknown-elf-objdump -S user/_zombie &gt; user/zombie.asm</span><br><span class="line">riscv64-unknown-elf-objdump -t user/_zombie | sed <span class="string">'1,/SYMBOL TABLE/d; s/ .* / /; /^$/d'</span> &gt; user/zombie.sym</span><br><span class="line">mkfs/mkfs fs.img README  user/xargstest.sh user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie </span><br><span class="line">nmeta 46 (boot, super, <span class="built_in">log</span> blocks 30 inode blocks 13, bitmap blocks 1) blocks 954 total 1000</span><br><span class="line">balloc: first 591 blocks have been allocated</span><br><span class="line">balloc: write bitmap block at sector 45</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line"></span><br><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">init: starting sh</span><br><span class="line">$ </span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用<code>ls</code> 输出<code>mkfs</code> 在初始文件系统中包含的文件</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">.              1 1 1024</span><br><span class="line">..             1 1 1024</span><br><span class="line">README         2 2 2059</span><br><span class="line">xargstest.sh   2 3 93</span><br><span class="line"><span class="built_in">cat</span>            2 4 24256</span><br><span class="line"><span class="built_in">echo</span>           2 5 23080</span><br><span class="line">forktest       2 6 13272</span><br><span class="line">grep           2 7 27560</span><br><span class="line">init           2 8 23816</span><br><span class="line"><span class="built_in">kill</span>           2 9 23024</span><br><span class="line"><span class="built_in">ln</span>             2 10 22880</span><br><span class="line"><span class="built_in">ls</span>             2 11 26448</span><br><span class="line"><span class="built_in">mkdir</span>          2 12 23176</span><br><span class="line"><span class="built_in">rm</span>             2 13 23160</span><br><span class="line">sh             2 14 41976</span><br><span class="line">stressfs       2 15 24016</span><br><span class="line">usertests      2 16 148456</span><br><span class="line">grind          2 17 38144</span><br><span class="line"><span class="built_in">wc</span>             2 18 25344</span><br><span class="line">zombie         2 19 22408</span><br><span class="line">console        3 20 0</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用<code>ctrl-a x</code> 退出<code>qemu</code> ，<code>Ctrl-a</code> 按完松手再按<code>x</code> 退出</p>
</li>
</ul>
<h2 id="二、Sleep实现（难度：easy）"><a href="#二、Sleep实现（难度：easy）" class="headerlink" title="二、Sleep实现（难度：easy）"></a>二、Sleep实现（难度：easy）</h2><blockquote>
<p>实现xv6的UNIX程序sleep：您的sleep应该暂停到用户指定的计时数。一个滴答(tick)是由xv6内核定义的时间概念，即来自定时器芯片的两个中断之间的时间</p>
</blockquote>
<p>学习<code>main</code> 函数的两个参数<code>argc</code> 和<code>argv[]</code> 的含义，将参数传入<code>sleep</code> 系统调用即可实现相关功能。</p>
<ul>
<li><code>argc</code> 是命令行总的参数个数。</li>
<li><code>argv[]</code> 为保存命令行参数的字符串指针。其中第0个参数是程序的全名，以后的参数为命令行后面跟的用户输入的参数。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "user/sleep.cpp"</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) {</span><br><span class="line">        <span class="type">char</span> *msg = {<span class="string">"please input sleep time, usage: ./sleep &lt;number&gt;\n"</span>};</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">sleep</span>(t);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>Makefile</code> 中<code>UPROGS</code> 处添加<code>$U/_sleep\</code> </p>
<h2 id="三、pingpong实现（难度：easy）"><a href="#三、pingpong实现（难度：easy）" class="headerlink" title="三、pingpong实现（难度：easy）"></a>三、pingpong实现（难度：easy）</h2><blockquote>
<p>实现xv6的UNIX程序pingpong：编写一个程序，使用UNIX系统调用在一对管道上的两个进程之间 “ping-pong” 一个字节，每个方向一个。父级应该向子级发送一个字节; 子级应该打印 “&lt;pid&gt;: received ping”，其中 &lt;pid&gt; 是其进程ID，将管道上的字节写入父级，然后退出; 父级应该从子级读取字节，打印 “&lt;pid&gt;: received pong”，然后退出。</p>
</blockquote>
<p>学习管道的使用，通过使用<code>pipe</code> 系统调用来实现管道功能，通过<code>fork</code> 系统调用来实现子进程的创建。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "user/pingpong.cpp"</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_SIZE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READEND 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITEEND 1</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *msg_f = <span class="string">"ping"</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *msg_s = <span class="string">"pong"</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> buf[MSG_SIZE];</span><br><span class="line">    <span class="type">int</span> pf[<span class="number">2</span>], ps[<span class="number">2</span>];   <span class="comment">// 创建管道输入端口和输出端口</span></span><br><span class="line">    <span class="type">int</span> ppf = <span class="built_in">pipe</span>(pf);   <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="type">int</span> pps = <span class="built_in">pipe</span>(ps);</span><br><span class="line">    <span class="keyword">if</span>(ppf &lt; <span class="number">0</span> || pps &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) {  <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关闭父进程管道的写端口以及子进程管道的读端口</span></span><br><span class="line">        <span class="built_in">close</span>(ps[READEND]);</span><br><span class="line">        <span class="built_in">close</span>(pf[WRITEEND]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">read</span>(pf[READEND], buf, MSG_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: received %s\n"</span>, <span class="built_in">getpid</span>(), buf);</span><br><span class="line">        <span class="built_in">write</span>(ps[WRITEEND], msg_s, MSG_SIZE);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    } <span class="keyword">else</span> {        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">close</span>(ps[WRITEEND]);</span><br><span class="line">        <span class="built_in">close</span>(pf[READEND]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(pf[WRITEEND], msg_f, MSG_SIZE);</span><br><span class="line">        <span class="built_in">read</span>(ps[READEND], buf, MSG_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: received %s\n"</span>, <span class="built_in">getpid</span>(), buf);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>Makefile</code> 中<code>UPROGS</code> 处添加<code>$U/_pingpong\</code> </p>
<h2 id="四、Primes实现（难度：moderate-hard）"><a href="#四、Primes实现（难度：moderate-hard）" class="headerlink" title="四、Primes实现（难度：moderate/hard）"></a>四、Primes实现（难度：moderate/hard）</h2><blockquote>
<p>使用管道编写prime sieve(筛选素数)的并发版本。</p>
</blockquote>
<ul>
<li>由于一个数的因数一定比该数本身小，所以可以使用比当前数小的所有素数进行筛选</li>
<li>如果当前数不是已确定的所有素数的倍数，则该数为素数</li>
<li>若该数为素数，则以该数为基创建子进程，并和与该数最接近的素数建立管道</li>
<li>对每个数都使用串联的所有素数进行判断，直到确定其为合数或素数</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "user/primes.cpp"</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READEND     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITEEND    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM     35</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prime</span><span class="params">(<span class="type">int</span> p[<span class="number">2</span>])</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">close</span>(p[WRITEEND]);</span><br><span class="line">    <span class="type">int</span> base;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">read</span>(p[READEND], &amp;base, <span class="built_in">sizeof</span>(<span class="type">int</span>))) {   <span class="comment">// 读取传来的数据</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"prime %d\n"</span>, base);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pr[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">pipe</span>(pr);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">prime</span>(pr);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">close</span>(pr[READEND]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">read</span>(p[READEND], &amp;num, <span class="built_in">sizeof</span>(<span class="type">int</span>))) {</span><br><span class="line">            <span class="keyword">if</span>(num % base != <span class="number">0</span>) {</span><br><span class="line">                <span class="built_in">write</span>(pr[WRITEEND], &amp;num, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">close</span>(pr[WRITEEND]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(p[READEND]);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> left;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pipe</span>(p);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">prime</span>(p);</span><br><span class="line">    } <span class="keyword">else</span> {    <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">close</span>(READEND);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAX_NUM; i++) {</span><br><span class="line">            left = i;</span><br><span class="line">            <span class="built_in">write</span>(p[WRITEEND], &amp;left, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">close</span>(p[WRITEEND]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>Makefile</code> 中<code>UPROGS</code> 处添加<code>$U/_primes\</code> </p>
<h2 id="五、find实现（难度：Moderate）"><a href="#五、find实现（难度：Moderate）" class="headerlink" title="五、find实现（难度：Moderate）"></a>五、find实现（难度：Moderate）</h2><blockquote>
<p>写一个简化版本的UNIX的find程序：查找目录树中具有特定名称的所有文件</p>
</blockquote>
<p>学习<code>ls</code> 的实现逻辑，遍历目录树，寻找指定的文件名即可。</p>
<ul>
<li>注意：处理目录树中的两个特殊文件<code>"."</code> 和<code>".."</code></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "user/find.cpp"</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/fs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ + <span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find first character after last slash.</span></span><br><span class="line">    <span class="keyword">for</span> (p = path + <span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">'/'</span>; p--)</span><br><span class="line">        ;</span><br><span class="line">    p++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return blank-padded name.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="built_in">memmove</span>(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    <span class="built_in">memset</span>(buf + <span class="built_in">strlen</span>(p), <span class="number">0</span>, DIRSIZ - <span class="built_in">strlen</span>(p));</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span> de;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"find: cannot open %s\n"</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fstat</span>(fd, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"find: cannot stat %s\n"</span>, path);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st.type)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> T_FILE:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="built_in">fmtname</span>(path), filename) == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, path);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> T_DIR:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"find: path too long\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">        p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">        *p++ = <span class="string">'/'</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">read</span>(fd, &amp;de, <span class="built_in">sizeof</span>(de)) == <span class="built_in">sizeof</span>(de))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (de.inum == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">memmove</span>(p, de.name, DIRSIZ);</span><br><span class="line">            p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">stat</span>(buf, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"find: cannot stat %s\n"</span>, buf);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, <span class="string">"."</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">".."</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">find</span>(buf, filename);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: find &lt;path&gt; &lt;filename&gt;\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">find</span>(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>Makefile</code> 中<code>UPROGS</code> 处添加<code>$U/_find\</code> </p>
<h2 id="六、xargs实现（难度：Moderate）"><a href="#六、xargs实现（难度：Moderate）" class="headerlink" title="六、xargs实现（难度：Moderate）"></a>六、xargs实现（难度：Moderate）</h2><blockquote>
<p>编写一个简化版UNIX的xargs程序：它从标准输入中按行读取，并且为每一行执行一个命令，将行作为参数提供给命令。</p>
</blockquote>
<p>这个题目在第一次做的时候还是很难理解的，主要是参考了<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/669622915">这篇文章</a></p>
<h3 id="1、xargs的作用"><a href="#1、xargs的作用" class="headerlink" title="1、xargs的作用"></a>1、xargs的作用</h3><p>我们知道管道<code>(pipe)</code> 是将前一个进程的输出<code>(stdout)</code> 作为下一下进程的输入<code>(stdin)</code> ，但是管道命令仅能处理<code>standard output</code> ，也就是说类似<code>less</code> 、<code>head</code> 、<code>tail</code> 等可以接受标准输入的命令。</p>
<p>而有很多命令不接收管道的传递方式，比如<code>ls</code> 和<code>echo</code> ，它们不能直接接收标准输入，而需要接收命令行参数，这时候就需要使用<code>xargs</code> 命令将管道传输过来的<code>stdin</code> 进行处理然后传递到命令的参数位上。也就是说，<code>xargs</code> 在这里执行了两个行为:</p>
<ul>
<li>处理管道左侧的标准输入</li>
<li>处理后传递到正确的位置上</li>
</ul>
<p>例如 <code>echo "one two three" | xargs mkdir</code> 等价于执行 <code>mkdir one two three</code> ，如果不加 <code>xargs</code> 则会提示 <code>mkdir</code> 缺少操作参数。</p>
<h3 id="2、实现思路"><a href="#2、实现思路" class="headerlink" title="2、实现思路"></a>2、实现思路</h3><p>事实上，就是从标准输入中读取字符串，直到遇到 <code>\n</code> 或 <code>\r</code> 则完成一次输入， 然后将所有的参数都读进来放在一个字符串数组里，然后将每一行都作为一个参数 <code>fork</code> 出一个子进程来执行 <code>exec</code> 系统调用。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/xargs.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/param.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mygets</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i + <span class="number">1</span> &lt; max; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> cc = <span class="built_in">read</span>(<span class="number">0</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (cc &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">' '</span> || c == <span class="string">'\n'</span> || c == <span class="string">'\r'</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        buf[i] = c;</span><br><span class="line">    }</span><br><span class="line">    buf[i] = <span class="string">'\0'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getcmd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> nbuf)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, nbuf);</span><br><span class="line">    <span class="built_in">mygets</span>(buf, nbuf);</span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// EOF标志位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"Usage: xargs &lt;command&gt;\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">char</span> *_argv[MAXARG];</span><br><span class="line">    <span class="type">int</span> _argc = argc - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _argc; i++)</span><br><span class="line">    {</span><br><span class="line">        _argv[i] = argv[i + <span class="number">1</span>]; <span class="comment">// 构造新命令参数，排除 "xargs" 这个字符串</span></span><br><span class="line">    }</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getcmd</span>(buf, <span class="built_in">sizeof</span>(buf)) != <span class="number">-1</span>)  <span class="comment">// 读取标准输入中的字符串，即其他命令执行的结果</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            _argv[_argc] = buf;</span><br><span class="line">            _argc++;</span><br><span class="line">            <span class="built_in">exec</span>(argv[<span class="number">1</span>], _argv);   <span class="comment">// argv[1] 为 xargs 要执行的命令</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"exec %s failed\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>Makefile</code> 中<code>UPROGS</code> 处添加<code>$U/_xargs\</code> </p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://raw.githubusercontent.com/Leven-comeon/picture-club/main/Lab1-Utils.png"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/operating-system" style=color:#00bcd4>
                operating system
            </a>
        </span>
        
    </div>

    <a href="/2024/05/06/6.s081/utils/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/04/29/dai-ma-sui-xiang-lu/zhan-he-dui-lie-jie-ti-zong-jie/">
        <h2>
            栈和队列解题总结
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/代码随想录">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                代码随想录
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/4/29
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="栈经典题目"><a href="#栈经典题目" class="headerlink" title="栈经典题目"></a>栈经典题目</h2><h3 id="栈在系统中的应用"><a href="#栈在系统中的应用" class="headerlink" title="栈在系统中的应用"></a>栈在系统中的应用</h3>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/栈和队列" style=color:#00a596>
                栈和队列
            </a>
        </span>
        
    </div>

    <a href="/2024/04/29/dai-ma-sui-xiang-lu/zhan-he-dui-lie-jie-ti-zong-jie/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/04/29/dai-ma-sui-xiang-lu/ha-xi-biao-jie-ti-zong-jie/">
        <h2>
            哈希表解题总结
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/代码随想录">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                代码随想录
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/4/29
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="哈希表经典题目"><a href="#哈希表经典题目" class="headerlink" title="哈希表经典题目"></a>哈希表经典题目</h2><h3 id="数组作为哈希表"><a href="#数组作为哈希表" class="headerlink" title="数组作为哈希表"></a>数组作为哈希表</h3><p>一些应用场景就是为数组量身定做的。</p>
<p>在<code>有效的字母异位词</code>中，我们提到了数组就是简单的哈希表，但是数组的大小是受限的！这道题目包含小写字母，那么使用数组来做哈希最合适不过。</p>
<p>在<code>赎金信</code>中同样要求只有小写字母，那么就给我们浓浓的暗示，用数组！本题和 有效的字母异位词 很像，有效的字母异位词 是求 字符串a 和 字符串b 是否可以相互组成，在 赎金信 中是求字符串a能否组成字符串b，而不用管 字符串b 能不能组成 字符串a。</p>
<p>上面两道题目用map确实可以，但使用map的空间消耗要比数组大一些，因为map要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效！</p>
<h3 id="set作为哈希表"><a href="#set作为哈希表" class="headerlink" title="set作为哈希表"></a>set作为哈希表</h3><p>在<code>两个数组的交集</code>中我们给出了什么时候用数组就不行了，需要用set。这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p>
<p>主要因为如下两点：</p>
<ul>
<li>数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。</li>
<li>如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。所以此时一样的做映射的话，就可以使用set了。</li>
</ul>
<p>关于set，C++ 给提供了如下三种可用的数据结构：</p>
<ul>
<li>std::set</li>
<li>std::multiset</li>
<li>std::unordered_set</li>
</ul>
<p>std::set 和 std::multiset 底层实现都是红黑树，std::unordered_set 的底层实现是哈希，使用 unordered_set 读写效率是最高的，本题并不需要对数据进行排序，而且还不要让数据重复，所以选择 unordered_set。</p>
<p>在<code>快乐数</code>中，我们再次使用了 unordered_set 来判断一个数是否重复出现过。</p>
<h3 id="map作为哈希表"><a href="#map作为哈希表" class="headerlink" title="map作为哈希表"></a>map作为哈希表</h3><p>在<code>两数之和</code>中map正式登场。</p>
<p>来说一说：使用数组和set来做哈希法的局限。</p>
<ul>
<li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li>
<li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li>
<li>map是一种&lt;key, value&gt;的结构，本题可以用key保存数值，用value在保存数值所在的下标。所以使用map最为合适。</li>
</ul>
<p>C++提供如下三种map：</p>
<ul>
<li>std::map</li>
<li>std::multimap</li>
<li>std::unordered_map</li>
</ul>
<p>std::unordered_map 底层实现为哈希，std::map 和std::multimap 的底层实现是红黑树。</p>
<p>同理，std::map 和 std::multimap 的 key 也是有序的，两数之和 中并不需要key有序，选择 std::unordered_map 效率更高！</p>
<p>在<code>四数相加 II</code>中我们提到了其实需要哈希的地方都能找到map的身影。</p>
<p>本题咋眼一看好像和 四数之和，三数之和 差不多，其实差很多！</p>
<p>关键差别是本题为四个独立的数组，只要找到 A[i] + B[j] + C[k] + D[l] &#x3D; 0 就可以，不用考虑重复问题，而 四数之和，三数之和 是一个数组（集合）里找到和为0的组合，可就难很多了！</p>
<p>用哈希法解决了两数之和，很多同学会感觉用哈希法也可以解决 三数之和，四数之和。</p>
<p>其实是可以解决，但是非常麻烦，需要去重导致代码效率很低。</p>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>在<code>三数之和</code>中我给出了 双指针 解法，大家就可以体会到，使用哈希法还是比较麻烦的。</p>
<p>所以 四数之和，三数之和 都推荐使用双指针法！</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/哈希表" style=color:#ff7d73>
                哈希表
            </a>
        </span>
        
    </div>

    <a href="/2024/04/29/dai-ma-sui-xiang-lu/ha-xi-biao-jie-ti-zong-jie/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/04/29/dai-ma-sui-xiang-lu/zi-fu-chuan-jie-ti-zong-jie/">
        <h2>
            字符串解题总结
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/代码随想录">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                代码随想录
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/4/29
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="字符串经典题目"><a href="#字符串经典题目" class="headerlink" title="字符串经典题目"></a>字符串经典题目</h2><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>在<code>反转字符串</code>，我们使用双指针法实现了反转字符串的操作，双指针法在数组，链表和字符串中很常用。</p>
<p>接着在字符串：<code>替换数字</code>，同样还是使用双指针法在时间复杂度$O(n)$的情况下完成替换空格。</p>
<p>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</p>
<p>那么针对数组删除操作的问题，其实在<code>移除元素</code>中就已经提到了使用双指针法进行移除操作。</p>
<p>同样的道理在<code>翻转字符串中的单词</code>中我们使用$O(n)$的时间复杂度，完成了删除冗余空格。</p>
<h3 id="反转系列"><a href="#反转系列" class="headerlink" title="反转系列"></a>反转系列</h3><p>在反转上还可以在加一些玩法，其实考察的是对代码的掌控能力。</p>
<p><code>反转字符串II</code>中，一些同学可能为了处理逻辑：每隔2k个字符的前k的字符，写了一堆逻辑代码或者再搞一个计数器，来统计2k，再统计前k个字符。其实当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。只要让 i +&#x3D; (2 * k) ，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。因为要找的也就是每2 * k 区间的起点，这样写程序会高效很多。</p>
<p>在<code>翻转字符串里的单词</code>中要求翻转字符串里的单词，这道题目可以说是综合考察了字符串的多种操作。是考察字符串的好题。这道题目通过 先整体反转再局部反转，实现了反转字符串里的单词。</p>
<p>后来发现反转字符串还有一个牛逼的用处，就是达到左旋的效果。在<code>右旋字符串</code>中，我们通过先局部反转再整体反转达到了左旋的效果。</p>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</p>
<p>KMP的精髓所在就是前缀表，在<code>实现strStr()</code>中提到了，什么是KMP，什么是前缀表，以及为什么要用前缀表。</p>
<ul>
<li>前缀表：起始位置到下标i之前（包括i）的子串中，有多大长度的相同前缀后缀。</li>
</ul>
<p>那么使用KMP可以解决两类经典问题：</p>
<p>匹配问题：<code>实现 strStr()</code><br>重复子串问题：<code>重复的子字符串</code><br>再一次强调了什么是前缀，什么是后缀，什么又是最长相等前后缀。</p>
<ul>
<li>前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。</li>
<li>后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串。</li>
</ul>
<p>其中主要理解 j&#x3D;next[x] 这一步最为关键！</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/字符串" style=color:#03a9f4>
                字符串
            </a>
        </span>
        
    </div>

    <a href="/2024/04/29/dai-ma-sui-xiang-lu/zi-fu-chuan-jie-ti-zong-jie/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/04/29/dai-ma-sui-xiang-lu/shu-zu-jie-ti-zong-jie/">
        <h2>
            数组解题总结
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/代码随想录">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                代码随想录
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/4/29
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="数组的经典题目"><a href="#数组的经典题目" class="headerlink" title="数组的经典题目"></a>数组的经典题目</h2><p>在面试中，数组是必考的基础数据结构。</p>
<p>其实数组的题目在思想上一般比较简单的，但是如果想高效，并不容易。</p>
<p>之前一共讲解了四种经典数组题目，每一种题目都代表一个类型，一种思想。</p>
<h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p><strong>第一道题目是二分法题目</strong></p>
<p>这道题目呢，考察数组的基本操作，思路很简单，但是通过率在简单题里并不高，不要轻敌。</p>
<p>可以使用暴力解法，通过这道题目，如果追求更优的算法，建议试一试用二分法，来解决这道题目</p>
<ul>
<li>暴力解法时间复杂度：$O(n)$ </li>
<li>二分法时间复杂度：$O(logn)$</li>
</ul>
<p>在这道题目中我们讲到了循环不变量原则，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。</p>
<p>二分法是算法面试中的常考题，建议通过这道题目，锻炼自己手撕二分的能力。</p>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p><strong>第二道题目和第三道题目都是双指针法，第二道使用快慢指针法，第三道使用高低指针法</strong></p>
<ol>
<li>双指针法（快慢指针法）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</li>
</ol>
<ul>
<li>暴力解法时间复杂度：$O(n^2)$</li>
<li>双指针时间复杂度：$O(n)$</li>
</ul>
<p>这道题目迷惑了不少同学，纠结于数组中的元素为什么不能删除，主要是因为以下两点：</p>
<ul>
<li>数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。</li>
<li>C++中vector和array的区别一定要弄清楚，vector的底层实现是array，封装后使用更友好。</li>
</ul>
<p>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。</p>
<ol start="2">
<li>双指针法（高低指针法）：通过一个从头开始的指针和一个从尾开始的指针，对向移动，在一个for循环下完成两个for循环的工作。</li>
</ol>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><strong>第四道题目是滑动窗口法</strong></p>
<ul>
<li>暴力解法时间复杂度：$O(n^2)$</li>
<li>滑动窗口时间复杂度：$O(n)$</li>
</ul>
<p>主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。</p>
<p>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将$O(n^2)$的暴力解法降为$O(n)$。</p>
<p>如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。</p>
<h3 id="模拟行为"><a href="#模拟行为" class="headerlink" title="模拟行为"></a>模拟行为</h3><p><strong>第五道题目是模拟题</strong></p>
<p>模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，十分考察对代码的掌控能力。</p>
<p>在这道题目中，我们再一次介绍到了<strong>循环不变量原则</strong>，其实这也是写程序中的重要原则。</p>
<p>相信大家有遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，拆了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实<strong>真正解决题目的代码都是简洁的，或者有原则性的</strong>，大家可以在这道题目中体会到这一点。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/数组" style=color:#00a596>
                数组
            </a>
        </span>
        
    </div>

    <a href="/2024/04/29/dai-ma-sui-xiang-lu/shu-zu-jie-ti-zong-jie/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            

            
            <a href="/">
                <span class="page-num">
                    1
                </span>
            </a>
        </span>
        

        <span class="current">
            2
        </span>

        

    </div>

    <div class="next">
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="images/头像.jpg " alt="头像">
        </div>
        <div class="name">
            leven
        </div>
        <div class="descriptions">
            
            <div class="description">
                一个苦逼的打工人
            </div>
            
            <div class="description">
                在追逐梦想的道路上砥砺前行……
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/leven-comeon">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="https://leven-comeon.github.io">

                    
                    <a-icon type="wechat"
                        theme="" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/zhi-zhi-zhe-13-21">

                    
                    <a-icon type="zhihu"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://space.bilibili.com/433368830?spm_id_from=333.1007.0.0">
                    bilibili链接
                </a>
            </div>
            
        </div>
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=5312668&auto=1&height=66"></iframe>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2022 - 2025 Leven
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @leven
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

    <script type="text/javascript" src="http://libs.baidu.com/jquery/1.8.3/jquery.js"></script>
    <script type="text/javascript" src="http://libs.baidu.com/jquery/1.8.3/jquery.min.js"></script>
    <!-- 鼠标滑动彩色特效 -->
    <script type="text/javascript" src="/js/hudongtexiao.js"></script>
    <script type="text/javascript" src="/js/love.js"></script>
    <!--动态线条背景-->
    <script type="text/javascript"
    color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
    </script>
    <!-- 雪花特效 -->
    <script type="text/javascript" src="/js/snow.js"></script>
    <!--人体时钟背景透明-->
    <!-- <script charset="Shift_JIS" src="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.js"></script> -->
</body>

</html> 