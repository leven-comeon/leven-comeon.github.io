<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>快手面经</title>
      <link href="/2025/09/14/mian-jing/kuai-shou-mian-jing/"/>
      <url>/2025/09/14/mian-jing/kuai-shou-mian-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="机器学习系统平台开发-一面"><a href="#机器学习系统平台开发-一面" class="headerlink" title="机器学习系统平台开发 一面"></a>机器学习系统平台开发 一面</h2><blockquote><p>2024.4.18面试 约1h30min 一面挂</p></blockquote><h3 id="1、算法题"><a href="#1、算法题" class="headerlink" title="1、算法题"></a>1、算法题</h3><p><a href="https://leetcode.cn/problems/lru-cache/description/">146. LRU缓存</a><br>中等难度，重点在于对双向链表的快速访问，使用<strong>unordered_map</strong>可以实现时间复杂度和空间复杂度都为$O(1)$</p><h3 id="2、C-八股"><a href="#2、C-八股" class="headerlink" title="2、C++八股"></a>2、C++八股</h3><ul><li>STL中容器的底层原理及其时间复杂度</li><li>模板类的实现</li><li>如果模板类的具体实现类是很占内存的结构体，如何修改参数传递来优化时间和空间？</li><li>右值引用与转移语义</li><li>docker与虚拟机的区别</li></ul><h3 id="3、简历内容拷问"><a href="#3、简历内容拷问" class="headerlink" title="3、简历内容拷问"></a>3、简历内容拷问</h3><h4 id="（1）基于FFT进行卷积加速的并行算法实现-项目"><a href="#（1）基于FFT进行卷积加速的并行算法实现-项目" class="headerlink" title="（1）基于FFT进行卷积加速的并行算法实现 项目"></a>（1）基于FFT进行卷积加速的并行算法实现 项目</h4><ul><li>这个项目的意义是什么？</li><li>使用CUDA加速用到哪些技巧？</li><li>哪些地方用到了共享内存？</li><li>在这个项目中，共享内存为什么能加速FFT计算?</li><li>算法正确性是怎么进行测试的？</li><li>测试的最大数据量有多大，如果数据量超过CUDA显存了还有什么优化手段？</li><li>听起来你的工作量就是将C++实现的FFT算法转换为了CUDA代码，然后使用共享内存进行加速，为什么会花了将近半年的时间?</li></ul><h4 id="（2）基于文本提示的图像编辑系统-项目"><a href="#（2）基于文本提示的图像编辑系统-项目" class="headerlink" title="（2）基于文本提示的图像编辑系统 项目"></a>（2）基于文本提示的图像编辑系统 项目</h4><ul><li>讲一下这个项目的内容</li><li>为什么要重新训练StyleGAN？</li><li>推理优化主要用了什么，为什么会快？</li><li>在部署过程中有遇到什么困难吗？</li></ul><h4 id="（3）系统文件备份软件-项目"><a href="#（3）系统文件备份软件-项目" class="headerlink" title="（3）系统文件备份软件 项目"></a>（3）系统文件备份软件 项目</h4><ul><li>怎么读目录树的？</li><li>怎么写入文件的？用了什么API？</li><li>网盘功能是怎么实现的？</li><li>如果文件大小超过电脑内存，该怎么读文件，有什么优化策略？</li></ul><h2 id="【暑期实习】大模型推理-训练引擎研发工程师-一面"><a href="#【暑期实习】大模型推理-训练引擎研发工程师-一面" class="headerlink" title="【暑期实习】大模型推理/训练引擎研发工程师 一面"></a>【暑期实习】大模型推理/训练引擎研发工程师 一面</h2><blockquote><p>2025.03.26面试 约 40 min 一面过</p></blockquote><h3 id="1、简历拷打"><a href="#1、简历拷打" class="headerlink" title="1、简历拷打"></a>1、简历拷打</h3><h4 id="（1）字节跳动实习经历"><a href="#（1）字节跳动实习经历" class="headerlink" title="（1）字节跳动实习经历"></a>（1）字节跳动实习经历</h4><ul><li>介绍一下模型结构、以及参数量有多大？</li><li>选用了什么推理方案？</li><li>相当于单机单卡去推吗？<ul><li>没有，使用了多大，使用 ulysses 进行推理</li></ul></li><li>详细讲一下激活权重量化和 dit cache？</li><li>怎么评价量化效果？</li><li>这样的 dit cache 在显存节省上有优势吗？</li><li>介绍一下 ulysses 通信量？<ul><li>核心是 all to all 通信量（当时没能答上来）</li></ul></li><li>all to all 有做 overlap 吗？如果要做，怎么设计？</li><li>介绍一下 ulysses 怎么使用 all to all？你能想到什么 overlap 方法？</li><li>介绍一下双向注意力修改这个项目？</li><li>dit 推理和 LLM 推理的最大区别是什么？<ul><li>dit 全是 compute bound，而 LLM 分为 prefill 和 decode 两个阶段，其中 prefill 是 compute bound，decode 是 I/O bound</li></ul></li><li>mmdit 有对 text 分支进行特殊优化吗？因为在 video generation model 中，text 分支的 seq_len 是比较小的，所以可以对 text 分支进行特殊优化？</li><li>为什么只做了 element-wise 融合？对 GEMM 没做融合吗？</li><li>有了解过 dit 训练过程吗？</li></ul><h4 id="（2）美团实习经历"><a href="#（2）美团实习经历" class="headerlink" title="（2）美团实习经历"></a>（2）美团实习经历</h4><ul><li>介绍一下 flash attention 优化这个项目？</li><li>了解 flash attention 原理吗？为什么比 native attention 又省显存又快？</li><li>使用 Tiling 方式计算 attention，怎么保证 softmax 的正确性？<ul><li>核心是介绍 online softmax</li></ul></li><li>你会手写算子吗？</li><li>你能介绍下 TP 怎么实现吗？</li><li>TP 里有一个 sequence parallel，你有了解吗？<ul><li>没有了解过</li></ul></li></ul><h3 id="2、代码题"><a href="#2、代码题" class="headerlink" title="2、代码题"></a>2、代码题</h3><p>用 triton 写一个简单矩阵乘，MxN 和 NxK 矩阵乘</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bilibili面经</title>
      <link href="/2025/09/14/mian-jing/bilibili-mian-jing/"/>
      <url>/2025/09/14/mian-jing/bilibili-mian-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="开发工程师（人工智能平台部）【2026届】-一面"><a href="#开发工程师（人工智能平台部）【2026届】-一面" class="headerlink" title="开发工程师（人工智能平台部）【2026届】 一面"></a>开发工程师（人工智能平台部）【2026届】 一面</h2><blockquote><p>2025.3.13 面试 约50min 一面过</p></blockquote><h3 id="1、简历拷打"><a href="#1、简历拷打" class="headerlink" title="1、简历拷打"></a>1、简历拷打</h3><h4 id="1-字节跳动实习经历"><a href="#1-字节跳动实习经历" class="headerlink" title="(1) 字节跳动实习经历"></a>(1) 字节跳动实习经历</h4><ul><li>介绍一下这段实习的内容</li><li>能讲一下模型结构吗？<ul><li>答：保密协议原因，实习生无权访问最新模型架构，旧版模型结构是：xxxxxxx</li></ul></li><li>你融合算子，是怎么知道要融合这几个的？<ul><li>答：旧版模型能接触到，通过 profile 工具导出 trace 图，分析找出可融合算子。</li></ul></li><li>都是在什么卡上进行的调优？</li><li>page attention 优化项目能否详细讲？</li><li>你们的 video caption 是什么样的模型？传统 video caption 可能只是使用 vit + cnn 提取特征然后使用 lstm 进行解码，然后现在有些模型是直接将输入特征拉平然后传入 LLM 进行生成，所以你们的模型是什么样的？<ul><li>答：我们的 video caption 是通过 ViT 将图像切成 patch 并拉平，然后还要从原始图像中提取出一个全局图像信息特征，作为 mask token。然后在 LLM 生成过程中，每次使用这个 mask token 拼接在输入序列后，使用这个全局信息特征作为请求计算得到的 logits 作为生成结果。在加速优化过程中，我们跟算法沟通，能否去掉这个 mask token 重训一版，算法表示可以，但懒得重训，因此我们采用优化 page attention 的方式来提升吞吐。</li></ul></li><li>优化 tensorrt-llm 时，你们是通过改 plugin 实现的吗？还是怎么实现的？<ul><li>答：我们更换 plugin，然后由于 plugin 只是计算 attention，因此我们在进入 plugin 前先对 qkv 做 rope，将加了 rope 后的 qkv 送入 plugin 进行计算。</li></ul></li><li>你觉得融合四个算子时，为什么提升这么大？<ul><li>答：减少了全局内存访问</li></ul></li><li>为什么不能直接用现有的融合算子实现？<ul><li>答：DiT 视频生成模型需要将图像和 text 的 embedding 进行拼接后再做后续操作，然后图像做 rope，文本不做 rope，因此不能提前拼接，所以现有的融合算子没有相关的实现。</li></ul></li><li>视频帧做 rope 时，时序信息怎么维持？<ul><li>答：在视频生成模型中，使用 3D rope，在计算 rotary embedding 时，需要的参数除了2d rope中的 h、w 外，还需要时序编号 t。因此在旋转编码中已经融入了时序信息。</li></ul></li><li>视频生成模型有多大？<ul><li>答：保密协议原因，具体数值不详。</li></ul></li><li>融合算子的时候是否考虑了 cp 或 sp?<ul><li>不需要，因为我融合的这几个算子都是 element-wise 的，序列并行并不会造成计算结果的错误以及通信量的增加。</li></ul></li></ul><h4 id="2-美团实习经历"><a href="#2-美团实习经历" class="headerlink" title="(2) 美团实习经历"></a>(2) 美团实习经历</h4><ul><li>原生多模态是指什么？</li><li>为什么要改 flash attention？</li><li>为什么不用 varlen 实现？<ul><li>用 varlen 也只能是不同长度的序列可以一起计算 attention，但他们使用的 attention 类型需要是一样的。我们的 mask 需要是不同部分使用 attention 类型是不同的。</li></ul></li></ul><h3 id="2、算法题"><a href="#2、算法题" class="headerlink" title="2、算法题"></a>2、算法题</h3><p>给定一个数组 nums 和一个目标值 target，m 次查询，每次给定一个区间 [l, r]，求在区间范围内是否存在两个数的异或等于 target。</p><h2 id="开发工程师（人工智能平台部）【2026届】-二面"><a href="#开发工程师（人工智能平台部）【2026届】-二面" class="headerlink" title="开发工程师（人工智能平台部）【2026届】 二面"></a>开发工程师（人工智能平台部）【2026届】 二面</h2><blockquote><p>2025.3.18 面试 约 30 min</p></blockquote><h3 id="唠家常"><a href="#唠家常" class="headerlink" title="唠家常"></a>唠家常</h3><ul><li>为什么要投递B站？考虑了哪些因素？<ul><li>答：考虑到转正率；以及对于基座 LLM 的推理训练了解比较少，来这里可以更多学到这方面的知识</li></ul></li></ul><h3 id="简历拷打"><a href="#简历拷打" class="headerlink" title="简历拷打"></a>简历拷打</h3><ul><li>为什么没有看到使用量化方法进行优化？<ul><li>答：我们使用一些典型测试集进行测试，观察模型中的激活数据分布和权重数据分布，发现我们的模型中的激活数据分布和权重数据分布都比较集中，异常值都比较小，所以没有使用特殊的量化方法进行优化。只是使用简单计算的方法进行量化。当然一些典型方法也是尝试过的，比如 smoothquant、awq等，我们也尝试了attention量化sage attention，效果还可以，但由于我们线上模型的attention占比比较小，所以也没有上。</li></ul></li><li>是否了解 tensorrt-llm、vllm 以及 sglang 等框架？<ul><li>答：从使用难度、性能、量化性能、特点等方面进行回答。sglang 的特点在与 redix attention，即 prefix cache。</li></ul></li><li>为什么 tensorrt-llm 要兼容双向注意力？</li><li>算子优化是有一个列表吗？还是怎么知道要有这些算子可优化点的？<ul><li>答：根据 profile 结果进行判断</li></ul></li><li>看起来做的事情都是比较杂，没有线性的工作，即在做一个优化的过程中出现了其他问题，然后解决这个问题，这是为什么？<ul><li>答：因为入职时间原因，我来的时候已经没有整块的可做的事了，只剩这些零碎的小问题。</li></ul></li><li>triton、cuda、cutlass 差异是什么，为什么没有使用 cuda 融合算子？</li><li>flash attention 优化做了什么，为什么能有这么大的性能提升？</li><li>对训练是否了解？比如并行这些？</li><li>多模态训练时是否支持变长？需要做 padding 吗？<ul><li>支持变长，没有做 padding，直接拼接，然后使用 varlen 实现。</li></ul></li><li>对 moe 是否做过尝试？moe 会存在什么问题？<ul><li>答：moe 可能存在负载不均衡、通信成本高等问题。</li></ul></li><li>是否以 compute bound 和 memory bound 为标准进行优化？</li><li>deepspeed 中的几个 zero stage 分别是什么？</li><li>profile 用的什么工具做的？有没有什么发现与预期不一致的情况？</li><li>对于模型稀疏性了解哪些？<ul><li>答：调研过 sparsity attention，包括 minference、nsa 等；还有 mla、flash mla 等。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小红书面经</title>
      <link href="/2024/12/07/mian-jing/xiao-hong-shu-mian-jing/"/>
      <url>/2024/12/07/mian-jing/xiao-hong-shu-mian-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="【26届实习】深度学习推理-训练引擎研发工程师-一面"><a href="#【26届实习】深度学习推理-训练引擎研发工程师-一面" class="headerlink" title="【26届实习】深度学习推理/训练引擎研发工程师 一面"></a>【26届实习】深度学习推理/训练引擎研发工程师 一面</h2><blockquote><p>2024.9.27 约1h10min 一面挂</p></blockquote><h3 id="1、简历内容拷问"><a href="#1、简历内容拷问" class="headerlink" title="1、简历内容拷问"></a>1、简历内容拷问</h3><h4 id="（1）美团实习经历"><a href="#（1）美团实习经历" class="headerlink" title="（1）美团实习经历"></a>（1）美团实习经历</h4><ul><li>flash Attention这块主要做了什么？</li><li>为什么要传最右可见下标，我理解kernel实现时传入完整Attention mask矩阵计算也是差不多的呀，mask矩阵跟输入比起来小很多？</li><li>推理框架里sd、flux、qwen2-vl等模型都是你自己接的？</li><li>对这些模型有没有做加速？</li><li>tensorrt应该不是针对大模型进行加速优化的吧？</li><li>vllm和tensorrt-llm的核心点是什么？</li><li>page attention主要解决了什么问题？（显存浪费角度回答）</li><li>为什么小模型时代没有page Attention这种方法，能不能有？（主要是大模型输出变长）</li><li>megatron中的并行方式有了解吗？</li><li>你了解的序列并行是怎么实现的？</li><li>张量并行是对于Attention和MLP中的矩阵乘法是怎么实现的？</li><li>为什么第一个矩阵乘法算完之后不需要进行通信？</li></ul><h4 id="（2）基于FFT进行卷积加速的并行算法实现-项目"><a href="#（2）基于FFT进行卷积加速的并行算法实现-项目" class="headerlink" title="（2）基于FFT进行卷积加速的并行算法实现 项目"></a>（2）基于FFT进行卷积加速的并行算法实现 项目</h4><ul><li>这个项目里主要用了什么优化方法？</li><li>cuda fft项目与cufft有对比过吗，效果如何？</li><li>为什么在被卷序列长度很大时会好于cuFFT，问题的核心是什么？</li><li>写过cuda，了解cutlass和triton吗？</li><li>shared memory使用时需要注意什么？（bank conflict）</li><li>bank conflict有什么解决办法？</li></ul><h3 id="2、代码考核"><a href="#2、代码考核" class="headerlink" title="2、代码考核"></a>2、代码考核</h3><p>用c++写一个模版类，实现三维数组按照指定维度转置</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美团面经</title>
      <link href="/2024/12/07/mian-jing/mei-tuan-mian-jing/"/>
      <url>/2024/12/07/mian-jing/mei-tuan-mian-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="大模型infra实习生-一面"><a href="#大模型infra实习生-一面" class="headerlink" title="大模型infra实习生 一面"></a>大模型infra实习生 一面</h2><blockquote><p>2024.4.22面试 约50min 一面过</p></blockquote><h3 id="1、简历拷打"><a href="#1、简历拷打" class="headerlink" title="1、简历拷打"></a>1、简历拷打</h3><h4 id="（1）基于文本提示的图像编辑系统-项目"><a href="#（1）基于文本提示的图像编辑系统-项目" class="headerlink" title="（1）基于文本提示的图像编辑系统 项目"></a>（1）基于文本提示的图像编辑系统 项目</h4><ul><li>我对你的这个项目很感兴趣，你讲一下吧</li><li>StyleGAN和CLIP是怎么进行交互从而实现文本提示编辑的？</li><li>训练数据量多大？怎么进行训练的?</li><li>网站的前后端分别使用什么编写的？</li><li>triton的原理有了解吗？</li><li>你这个模型算是小模型，大模型的训练不能直接单卡训练，有了解大模型训练相关技术吗？</li><li>deepspeed原理有了解吗？</li></ul><h4 id="（2）基于FFT进行卷积加速的并行算法实现-项目"><a href="#（2）基于FFT进行卷积加速的并行算法实现-项目" class="headerlink" title="（2）基于FFT进行卷积加速的并行算法实现 项目"></a>（2）基于FFT进行卷积加速的并行算法实现 项目</h4><ul><li>讲一下这个项目吧</li><li>加速的技巧有哪些?</li><li>这个算法有实际应用吗？</li></ul><h4 id="（3）系统文件备份软件-项目"><a href="#（3）系统文件备份软件-项目" class="headerlink" title="（3）系统文件备份软件 项目"></a>（3）系统文件备份软件 项目</h4><ul><li>讲一下这个项目</li><li>哈夫曼编码使用了什么库吗还是手写？</li></ul><h3 id="2、大模型八股"><a href="#2、大模型八股" class="headerlink" title="2、大模型八股"></a>2、大模型八股</h3><ul><li>有了解现在市场上的大模型吗？包括国内的、国外的</li><li>你用下来的感受如何？</li><li>大模型比小模型性能强的原因有哪些？</li><li>多模态大模型有了解过吗?</li><li>大模型的结构有了解吗？</li><li>能讲一下Transformer的结构吗？</li><li>你知道在Transformer之前，人们最常使用的具有长短期记忆功能的网络有哪些吗？</li><li>你知道Transformer比LSTM的优势在哪吗？</li><li>你说你以后想做模型推理优化，你了解推理优化方法吗?</li></ul><h3 id="3、算法题"><a href="#3、算法题" class="headerlink" title="3、算法题"></a>3、算法题</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/description/">92. 反转链表 II</a><br>中等难度，可以看作反转整个链表题目的进阶</p><ul><li>创建虚拟头结点，提前用全局变量<code>pre</code>保存开始反转的前一个节点</li><li>与反转整个链表不同，递归到最后需要用全局变量<code>tail</code>保存最后一个节点的下一个节点</li><li>递归进行反转，递归过程中将<code>head-&gt;next</code>设置为<code>tail</code>而非<code>null</code></li><li>将递归返回赋值给<code>pre-&gt;next</code></li><li>返回虚拟头结点的<code>next</code>即可</li></ul><h2 id="大模型infra实习生-二面"><a href="#大模型infra实习生-二面" class="headerlink" title="大模型infra实习生 二面"></a>大模型infra实习生 二面</h2><blockquote><p>2024.4.25面试 约40min 二面过</p></blockquote><h3 id="1、算法题"><a href="#1、算法题" class="headerlink" title="1、算法题"></a>1、算法题</h3><h4 id="（1）求所有根节点到叶节点的路径总和"><a href="#（1）求所有根节点到叶节点的路径总和" class="headerlink" title="（1）求所有根节点到叶节点的路径总和"></a>（1）求所有根节点到叶节点的路径总和</h4><p>假设路径为<code>1-&gt;2-&gt;3</code>，则将该路径值看作<code>123</code>，求所有路径值的总和</p><ul><li>dfs遍历路径值</li><li>对得到的路径值求和</li></ul><h4 id="（2）删除链表中所有重复节点"><a href="#（2）删除链表中所有重复节点" class="headerlink" title="（2）删除链表中所有重复节点"></a>（2）删除链表中所有重复节点</h4><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/">82. 删除排序链表中的重复元素 II</a></p><ul><li>创建虚拟头结点进行简化</li><li>双指针进行循环删除</li></ul><h3 id="2、基础八股"><a href="#2、基础八股" class="headerlink" title="2、基础八股"></a>2、基础八股</h3><ul><li><code>vector/map/unordered_map/list</code>的底层实现原理以及相应的访存时间复杂度，以及迭代器的变化规则</li><li>红黑树怎么保持平衡的？</li><li><code>top/grep/ls/ps/awk</code>分别是干什么的?</li><li>对<code>Transformer</code>了解吗？讲一下它的结构吧（包含了压力测试，我说完了，他问我你确定？）</li><li>讲一下C++中的多态实现</li><li>什么是虚函数？</li><li>对多线程编程了解还是对网络编程了解？（由于我对二者都不太了解，所以后面没有问相关问题）</li></ul><h3 id="3、简历拷打"><a href="#3、简历拷打" class="headerlink" title="3、简历拷打"></a>3、简历拷打</h3><h4 id="（1）基于FFT进行卷积加速的并行算法实现-项目"><a href="#（1）基于FFT进行卷积加速的并行算法实现-项目" class="headerlink" title="（1）基于FFT进行卷积加速的并行算法实现 项目"></a>（1）基于FFT进行卷积加速的并行算法实现 项目</h4><ul><li>讲一下这个项目吧</li><li>为什么想到要用cuda进行加速</li><li>cuda streams中，异步搬运数据会占用线程吗？</li></ul><h2 id="大模型infra实习生-offer-2024-4-28-最终去向，5-13入职"><a href="#大模型infra实习生-offer-2024-4-28-最终去向，5-13入职" class="headerlink" title="大模型infra实习生 offer 2024.4.28 最终去向，5.13入职"></a>大模型infra实习生 offer 2024.4.28 最终去向，5.13入职</h2>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯面经</title>
      <link href="/2024/12/07/mian-jing/teng-xun-mian-jing/"/>
      <url>/2024/12/07/mian-jing/teng-xun-mian-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="IEG-后台开发-一面"><a href="#IEG-后台开发-一面" class="headerlink" title="IEG 后台开发 一面"></a>IEG 后台开发 一面</h2><blockquote><p>2024.4.30 面试 约50min 一面过</p></blockquote><h3 id="1、简历拷打"><a href="#1、简历拷打" class="headerlink" title="1、简历拷打"></a>1、简历拷打</h3><h4 id="（1）基于文本提示的图像编辑系统-项目"><a href="#（1）基于文本提示的图像编辑系统-项目" class="headerlink" title="（1）基于文本提示的图像编辑系统 项目"></a>（1）基于文本提示的图像编辑系统 项目</h4><ul><li>看你用到了triton inference server，讲一下你在使用过程中觉得它有什么缺点吧？</li><li>StyleCLIP是开源的模型结构吗？</li></ul><h4 id="（2）系统备份软件-项目"><a href="#（2）系统备份软件-项目" class="headerlink" title="（2）系统备份软件 项目"></a>（2）系统备份软件 项目</h4><ul><li>项目特色是什么？</li><li>网络传输功能是使用什么传输协议？</li><li>tcp和udp的区别是什么？</li><li>tcp是可靠的，udp是不可靠的，有什么办法能够使udp可靠？</li><li>为什么tcp断开连接需要使用四次挥手？</li></ul><h4 id="（3）基于FFT进行卷积加速的并行算法实现-项目"><a href="#（3）基于FFT进行卷积加速的并行算法实现-项目" class="headerlink" title="（3）基于FFT进行卷积加速的并行算法实现 项目"></a>（3）基于FFT进行卷积加速的并行算法实现 项目</h4><ul><li>是从一开始就使用<code>cuda</code>实现的<code>FFT</code>还是重构的？</li><li>这个项目的特色是什么？</li><li>为什么<code>cuda stream</code>能够进行加速？</li><li>共享内存是怎么利用的？</li><li>线程块和线程束的区别是什么？</li><li>还有想过其他加速方式吗？</li></ul><h3 id="2、基础八股文"><a href="#2、基础八股文" class="headerlink" title="2、基础八股文"></a>2、基础八股文</h3><ul><li><code>c++</code>有了解吗？</li><li><code>STL</code>中的模版类使用过吗？<code>map</code>和<code>unordered_map</code>有什么区别？分别适用于什么场景？</li><li>哈希冲突的解决办法有哪些？分别解释一下</li><li>多态是怎么实现的？</li><li>什么是虚函数？</li><li>什么时候会用到虚析构函数？</li><li>为什么数据库要使用<code>B+</code>树？（由于对数据库底层不了解，所以没有往下问）</li><li>大模型了解吗？讲一下<code>Transformer</code>的<code>decoder</code>结构？</li><li>为什么要用多头，而不用单头？</li><li>刚刚提到多头注意力机制的输入中的<code>Q</code>矩阵来自于<code>encoder</code>结果，那如果没有<code>encoder</code>，单独使用<code>decoder</code>时，这个<code>Q</code>怎么获得？</li><li><code>Transformer</code>相比于<code>LSTM</code>的特点是什么？为什么要从<code>LSTM</code>更新到<code>Transformer</code>?<ul><li>提示：从注意力机制的作用角度回答</li></ul></li></ul><h3 id="3、算法题"><a href="#3、算法题" class="headerlink" title="3、算法题"></a>3、算法题</h3><p><a href="https://leetcode.cn/problems/lru-cache/description/">146. LRU缓存</a><br>详见<a href="https://leven-comeon.github.io/2024/04/29/mian-jing/kuai-shou-mian-jing/">快手面经</a></p><h2 id="IEG-后台开发-二面"><a href="#IEG-后台开发-二面" class="headerlink" title="IEG 后台开发 二面"></a>IEG 后台开发 二面</h2><blockquote><p>2024.5.6 面试 约40min 二面过</p></blockquote><h2 id="IEG-后台开发-三面（主管面）"><a href="#IEG-后台开发-三面（主管面）" class="headerlink" title="IEG 后台开发 三面（主管面）"></a>IEG 后台开发 三面（主管面）</h2><blockquote><p>2024.5.11 面试 约30min 三面过</p></blockquote><h2 id="IEG-后台开发-HR面"><a href="#IEG-后台开发-HR面" class="headerlink" title="IEG 后台开发 HR面"></a>IEG 后台开发 HR面</h2><blockquote><p>约了 2024.5.14 面试，放弃</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab 3: page tables</title>
      <link href="/2024/05/09/6.s081/pgtbl/"/>
      <url>/2024/05/09/6.s081/pgtbl/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-3-page-tables"><a href="#Lab-3-page-tables" class="headerlink" title="Lab 3: page tables"></a>Lab 3: page tables</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>将<code>xv6</code> 代码切换到<code>pgtbl</code> 分支并初始化</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout pgtbl</span><br><span class="line">$ make clean</span><br></pre></td></tr></tbody></table></figure><h2 id="一、加速系统调用（难度：easy）"><a href="#一、加速系统调用（难度：easy）" class="headerlink" title="一、加速系统调用（难度：easy）"></a>一、加速系统调用（难度：easy）</h2><blockquote><p>在内核和用户态之间创建一个共享的只读页，是用户态能够直接读取内核态写入的数据，从而加速系统调用。这里的页指页表中用户态和内核态均可读的一个 PTE，其指向一块物理内存。</p></blockquote><h3 id="1、基本原理"><a href="#1、基本原理" class="headerlink" title="1、基本原理"></a>1、基本原理</h3><p>用户态是不能直接读取内核态的数据，而是要通过系统调用。如果创建一个可读 <code>PTE</code> 指向一块内存，该 <code>PTE</code> 是用户态和内核态共享的，那么用户态就可以直接读取这块内核数据，而无需经过复杂的系统调用。为每一个进程多分配一个虚拟地址位于 <code>USYSCALL</code> 的页，然后这个页的开头保存一个 <code>usyscall</code> 结构体，结构体中存放这个进程的 <code>pid</code>。</p><h3 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a>2、具体实现</h3><ul><li><p><code>USYSCALL</code> 页是独立于进程页表的一个页，把定义加到<code>kernel/proc.h</code> 的<code>proc</code> 结构体中：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span>{</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">usyscall</span> *usyscall;  <span class="comment">// to spped up user's syscall</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>在<code>kernel/proc.c</code> 中初始化该页，在<code>allocproc</code> 函数中分配<code>usyscall</code> 结构体，并将进程号写入结构体中</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">proc</span> * <span class="built_in">allocproc</span>(<span class="type">void</span>){</span><br><span class="line">    ...</span><br><span class="line">found:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// allocate a syscall page</span></span><br><span class="line">    <span class="keyword">if</span> ((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall *)<span class="built_in">kalloc</span>()) == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">freeproc</span>(p);</span><br><span class="line">        <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// An empty user page table.</span></span><br><span class="line">    p-&gt;pagetable = <span class="built_in">proc_pagetable</span>(p);</span><br><span class="line">    ...</span><br><span class="line">    p-&gt;usyscall-&gt;pid = p-&gt;pid;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>由于用户态寻址的时候都要经过页表硬件的翻译，所以<code>usyscall</code> 也要映射在进程的<code>pagetable</code> 上，在<code>proc_pagetable()</code> 中加入映射逻辑：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">pagetable_t</span> <span class="title">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span>{</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mappages</span>(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usyscall),</span><br><span class="line">                 PTE_R | PTE_U) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">uvmunmap</span>(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">uvmunmap</span>(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">uvmfree</span>(pagetable, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pagetable;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>在进程回收时，需要将该页一起回收</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;usyscall)</span><br><span class="line">        <span class="built_in">kfree</span>((<span class="type">void</span> *)p-&gt;usyscall);</span><br><span class="line">    p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>解除页表中的映射</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">uvmunmap</span>(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">uvmfree</span>(pagetable, sz);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="二、打印页表（难度：easy）"><a href="#二、打印页表（难度：easy）" class="headerlink" title="二、打印页表（难度：easy）"></a>二、打印页表（难度：easy）</h2><blockquote><p>实现一个内核函数 vmprint，其接收一个 pagetable，能够将其中所有的可用 PTE 的信息全部打印出来。</p></blockquote><h3 id="1、解题思路"><a href="#1、解题思路" class="headerlink" title="1、解题思路"></a>1、解题思路</h3><p>递归遍历页表，碰到有效的就遍历进下一层页表</p><h3 id="2、具体实现-1"><a href="#2、具体实现-1" class="headerlink" title="2、具体实现"></a>2、具体实现</h3><ul><li><p>在<code>kernel/vm.c</code> 中新增页表打印函数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vmprint_kenel</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">        <span class="keyword">if</span> (pte &amp; PTE_V)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">            uint64 child = <span class="built_in">PTE2PA</span>(pte);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; level; k++)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" .."</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d: pte %p pa %p\n"</span>, i, pte, child);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (level &lt; <span class="number">3</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">vmprint_kenel</span>((<span class="type">pagetable_t</span>)child, level + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"page table %p\n"</span>, pagetable);</span><br><span class="line">    <span class="built_in">vmprint_kenel</span>(pagetable, <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>在<code>kernel/defs.h</code> 函数中声明<code>vmprint</code> 函数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line"><span class="comment">// vm.c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vmprint</span><span class="params">(<span class="type">pagetable_t</span>)</span></span>;</span><br><span class="line">  ...</span><br></pre></td></tr></tbody></table></figure></li><li><p>为了启动内核时打印页表，在<code>kernel/exec.c</code> 中的<code>exec</code> 函数中加入以下内容</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line"><span class="keyword">if</span> (p-&gt;pid == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">vmprint</span>(p-&gt;pagetable);</span><br><span class="line"><span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line">  ...</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="三、检测页面是否访问（难度：hard）"><a href="#三、检测页面是否访问（难度：hard）" class="headerlink" title="三、检测页面是否访问（难度：hard）"></a>三、检测页面是否访问（难度：hard）</h2><blockquote><p>实验要求实现一个系统调用 sys_pgaccess，其会从一个虚拟地址对应的 PTE 开始，往下搜索一定数量的被访问（read/write）过的页表，并把结果通过 mask 的方式返回给用户。每当 sys_pgacess 调用一次，页表被访问标志就要清 0。</p></blockquote><h3 id="1、解题思路-1"><a href="#1、解题思路-1" class="headerlink" title="1、解题思路"></a>1、解题思路</h3><p>该题的关键是要解决两个问题：怎么知道哪些页表被访问了、怎么通过虚拟地址依次遍历后续 <code>PTE</code>？</p><ul><li>怎么知道哪些页表被访问了?<ul><li>检查页表中的<code>PTE_A</code> 标识位。该位被置 1 则说明被访问过，该位被置 0 则说明没被访问过。</li><li>置位操作有硬件完成，无需我们考虑。但是，硬件只能做到置位，无法做到复位。因此每次 <code>sys_pgacess</code> 时要手动将 <code>PTE_A</code> 复位 0。</li></ul></li><li>怎么通过虚拟地址依次遍历后续 <code>PTE</code>?<ul><li>首先，通过 <code>walk</code> 可得到虚拟地址对应的 <code>PTE</code></li><li>其次，<code>PTE</code> 是连续的，那么对应的虚拟地址也应是连续的</li><li>最后，一个 <code>PTE</code> 大小为 <code>PGSIZE</code>，因此只要将虚拟地址按 <code>PGSIZE</code> 累加即可得到后续的 <code>PTE</code></li></ul></li></ul><p><code>PTE_A</code> 的值在第 6 位。</p><h3 id="2、具体实现-2"><a href="#2、具体实现-2" class="headerlink" title="2、具体实现"></a>2、具体实现</h3><ul><li><p>在 <code>kernel/riscv.h</code> 中加入<code>PTE_A</code> 的宏定义</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1L <span class="string">&lt;&lt; 6) // 1 -&gt;</span> have accessed</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>在 <code>kernel/sysproc.c</code> 中完善 <code>sys_pgaccess</code> 函数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="function">uint64 <span class="title">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">    <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">    <span class="comment">// get argument</span></span><br><span class="line">    uint64 buf;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    uint64 ans;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">argaddr</span>(<span class="number">0</span>, &amp;buf) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">argint</span>(<span class="number">1</span>, &amp;number) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">argaddr</span>(<span class="number">2</span>, &amp;ans) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pgaccess</span>((<span class="type">void</span>*)buf, number, (<span class="type">void</span>*)ans);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure></li><li><p>在<code>kernel/proc.c</code> 中 新增 <code>pgaccess</code> 函数，用于具体实现页的访问</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">pgaccess</span><span class="params">(<span class="type">void</span> *addr, <span class="type">int</span> n, <span class="type">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">pagetable_t</span> pagetable = p-&gt;pagetable;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">pte_t</span> *pte;</span><br><span class="line">        pte = <span class="built_in">walk</span>(pagetable, (uint64)addr + (uint64)PGSIZE * i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (pte &amp;&amp; ((*pte) &amp; PTE_A))</span><br><span class="line">        {</span><br><span class="line">            ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            (*pte) ^= PTE_A;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">copyout</span>(pagetable, (uint64)buf, (<span class="type">char</span> *)&amp;ans, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>在<code>kernel/defs.h</code> 中加入<code>pgaccess</code> 函数声明</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">pgaccess</span><span class="params">(<span class="type">void</span> *addr, <span class="type">int</span> n, <span class="type">void</span> *buf)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://raw.githubusercontent.com/leven-comeon/picture-club/main/202405082224016.png"></p>]]></content>
      
      
      <categories>
          
          <category> MIT </category>
          
          <category> 6.S081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab 2: system calls</title>
      <link href="/2024/05/07/6.s081/syscall/"/>
      <url>/2024/05/07/6.s081/syscall/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-2-system-calls"><a href="#Lab-2-system-calls" class="headerlink" title="Lab 2: system calls"></a>Lab 2: system calls</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>将<code>xv6</code> 代码切换到<code>syscall</code> 分支并初始化</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout syscall</span><br><span class="line">$ make clean</span><br></pre></td></tr></tbody></table></figure><h2 id="一、trace-系统调用（难度：moderate）"><a href="#一、trace-系统调用（难度：moderate）" class="headerlink" title="一、trace 系统调用（难度：moderate）"></a>一、trace 系统调用（难度：moderate）</h2><blockquote><p>添加一个trace system call调用，可以实现跟踪system call。此函数入参为一个数字，可以控制跟踪哪些system call。如：</p><p><code>trace(1&lt;&lt;SYS_fork)，trace(10b)，trace(2)</code> 表示跟踪fork调用；</p><p><code>trace(1&lt;&lt;SYS_read)，trace(10 0000b)，trace(32)</code> 表示跟踪read调用；</p><p><code>trace(10 0010b)，trace(34)</code> 表示跟踪fork、read调用；</p></blockquote><h3 id="1、系统调用流程"><a href="#1、系统调用流程" class="headerlink" title="1、系统调用流程"></a>1、系统调用流程</h3><p>用户态中：</p><ul><li>在<code>user/user.h</code> 做函数声明</li><li><code>Makefile</code> 调用<code>usys.pl（perl脚本）</code> 生成<code>usys.S</code> ，里面写了具体实现，通过<code>ecall</code> 进入 kernel，通过设置寄存器<code>a7</code> 的值，表明调用哪个system call</li><li><code>ecall</code> 执行后存储用户态上下文信息到进程的<code>trapframe</code> 结构体中，并加载内核态页表、寄存器等信息</li></ul><p>内核态中：</p><ul><li>开始执行<code>syscall</code> 函数，通过读取<code>trapframe</code> 中<code>a7</code> 寄存器的值，判断系统调用类型</li><li>通过函数指针执行对应内核函数，实现系统调用功能</li></ul><h3 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a>2、具体实现</h3><ul><li>在<code>user/user.h</code> 中申明<code>sys_trace</code> 函数<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trace</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li><li>在<code>user/usys.pl</code> 中定义函数 entry<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">entry</span>(<span class="string">"trace"</span>);</span><br></pre></td></tr></tbody></table></figure></li><li>在<code>Makefile</code> 中添加<code>$U/_trace</code> </li><li>在<code>kernel/syscall.h</code> 中添加系统调用号宏定义<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace 22</span></span><br></pre></td></tr></tbody></table></figure></li><li>在<code>kernel/proc.h</code> 的<code>proc</code> 结构体中增加<code>mask</code> 数组<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">procstate</span> state; <span class="comment">// Process state</span></span><br><span class="line">    <span class="type">void</span> *chan;           <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">    <span class="type">int</span> killed;           <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">    <span class="type">int</span> xstate;           <span class="comment">// Exit status to be returned to parent's wait</span></span><br><span class="line">    <span class="type">int</span> pid;              <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *parent; <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">    uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">    uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">    <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">trapframe</span> *trapframe; <span class="comment">// data page for trampoline.S</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">context</span> context;      <span class="comment">// swtch() here to run process</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> *ofile[NOFILE];  <span class="comment">// Open files</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">inode</span> *cwd;           <span class="comment">// Current directory</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">    <span class="type">char</span> mask[<span class="number">32</span>];               <span class="comment">// Trace mask</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li><li>在<code>kernel/sysproc.c</code> 新增函数<code>sys_trace</code> ，将系统调用号存入到<code>proc</code> 结构体的<code>mask</code> 数组中<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">argint</span>(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">    <span class="type">char</span> *mask = p-&gt;mask;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; i &lt; <span class="number">32</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>)</span><br><span class="line">        {</span><br><span class="line">            mask[i++] = <span class="string">'1'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            mask[i++] = <span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>在<code>kernel/syscall.c</code> 中引入<code>sys_trace</code> 函数申明，并与系统调用号进行关联<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 (*syscalls[])(void) 中添加以下内容</span></span><br><span class="line">[SYS_trace] sys_trace,</span><br></pre></td></tr></tbody></table></figure></li><li>在<code>kernel/syscall.c</code> 中新建一个数组存放<code>system_call</code> 的名称<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *syscall_names[<span class="number">32</span>] = {<span class="string">""</span>, <span class="string">"fork"</span>, <span class="string">"exit"</span>, <span class="string">"wait"</span>, <span class="string">"pipe"</span>, <span class="string">"read"</span>, <span class="string">"kill"</span>, <span class="string">"exec"</span>, <span class="string">"fstat"</span>, <span class="string">"chdir"</span>, <span class="string">"dup"</span>, <span class="string">"getpid"</span>, <span class="string">"sbrk"</span>, <span class="string">"sleep"</span>, <span class="string">"uptime"</span>, <span class="string">"open"</span>, <span class="string">"write"</span>, <span class="string">"mknod"</span>, <span class="string">"unlink"</span>, <span class="string">"link"</span>, <span class="string">"mkdir"</span>, <span class="string">"close"</span>, <span class="string">"trace"</span>};</span><br></pre></td></tr></tbody></table></figure></li><li>在<code>kernel/syscall.c</code> 的<code>syscall</code> 函数中实现具体的跟踪功能，即判断当前系统调用号是否在需要跟踪的<code>mask</code> 中<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">syscall</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">    num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="built_in">NELEM</span>(syscalls) &amp;&amp; syscalls[num])</span><br><span class="line">    {</span><br><span class="line">        p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">        <span class="comment">// trace begin</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(p-&gt;mask) &gt; <span class="number">0</span> &amp;&amp; p-&gt;mask[num] == <span class="string">'1'</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d: syscall %s -&gt; %d\n"</span>, p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// trace end</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %s: unknown sys call %d\n"</span>,</span><br><span class="line">               p-&gt;pid, p-&gt;name, num);</span><br><span class="line">        p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>在<code>kernel/proc.c</code> 的<code>fork</code> 函数中实现自动复制父进程的<code>mask</code> <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">uvmcopy</span>(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">freeproc</span>(np);</span><br><span class="line">    <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line">np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy mask from parent to child</span></span><br><span class="line"><span class="built_in">safestrcpy</span>(np-&gt;mask, p-&gt;mask, <span class="built_in">sizeof</span>(p-&gt;mask));</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy saved user registers.</span></span><br><span class="line">*(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="二、sysinfo-系统调用（难度：moderate）"><a href="#二、sysinfo-系统调用（难度：moderate）" class="headerlink" title="二、sysinfo 系统调用（难度：moderate）"></a>二、sysinfo 系统调用（难度：moderate）</h2><blockquote><p>添加一个 sysinfo system call 调用，可以实现打印可用空间(字节)、可用进程数。</p></blockquote><h3 id="1、具体实现"><a href="#1、具体实现" class="headerlink" title="1、具体实现"></a>1、具体实现</h3><ul><li>在<code>user/user.h</code> 中申明<code>sysinfo</code> 结构体并申明<code>sys_sysinfo</code> 函数<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sysinfo</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li><li>在<code>user/usys.pl</code> 中定义函数 entry<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">entry</span>(<span class="string">"sysinfo"</span>);</span><br></pre></td></tr></tbody></table></figure></li><li>在<code>Makefile</code> 中添加<code>$U/_sysinfotest</code> </li><li>在<code>kernel/syscall.h</code> 中添加系统调用号宏定义<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sysinfo 23</span></span><br></pre></td></tr></tbody></table></figure></li><li>在<code>kernel/kalloc.c</code> 新增函数<code>freemem_size</code> 用来统计可用空间大小<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">freemem_size</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (r = kmem.freelist; r; r = r-&gt;next)</span><br><span class="line">    {</span><br><span class="line">        num++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> num * PGSIZE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>在<code>kernel/proc.c</code> 新增函数<code>proc_num</code> 用来统计可用进程数<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">proc_num</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line">    uint64 num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state != UNUSED)</span><br><span class="line">            num++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>在<code>kernel/defs.h</code> 中申明上面添加的两个函数<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">kalloc</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kfree</span><span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kinit</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">freemem_size</span><span class="params">(<span class="type">void</span>)</span></span>;     <span class="comment">// 新增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// proc.c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cpuid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exit</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">growproc</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc_mapstacks</span><span class="params">(<span class="type">pagetable_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">pagetable_t</span> <span class="title">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span>, uint64)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cpu</span> *<span class="built_in">mycpu</span>(<span class="type">void</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cpu</span> *<span class="built_in">getmycpu</span>(<span class="type">void</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span> *<span class="built_in">myproc</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">procinit</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scheduler</span><span class="params">(<span class="type">void</span>)</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sched</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">(<span class="type">void</span> *, <span class="keyword">struct</span> spinlock *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">userinit</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wait</span><span class="params">(uint64)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wakeup</span><span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yield</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">either_copyout</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">void</span> *src, uint64 len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">either_copyin</span><span class="params">(<span class="type">void</span> *dst, <span class="type">int</span> user_src, uint64 src, uint64 len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">procdump</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">proc_num</span><span class="params">(<span class="type">void</span>)</span></span>;     <span class="comment">// 新增</span></span><br></pre></td></tr></tbody></table></figure></li><li>在<code>kernel/sysproc.c</code> 引入<code>sysinfo.h</code> ，并新增函数<code>sys_sysinfo</code> ，调用上面的两个函数并将结果封装到<code>sysinfo</code> 结构体中，使用<code>copyout</code> 函数将结构体传回用户态<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"sysinfo.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">uint64 <span class="title">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    uint64 addr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sysinfo</span> info;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">argaddr</span>(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    info.freemem = <span class="built_in">freemem_size</span>();</span><br><span class="line">    info.nproc = <span class="built_in">proc_num</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">copyout</span>(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;info, <span class="built_in">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>在<code>kernel/syscall.c</code> 中引入<code>sys_sysinfo</code> 函数申明，并与系统调用号进行关联<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 (*syscalls[])(void) 中添加以下内容</span></span><br><span class="line">[SYS_sysinfo] sys_sysinfo,</span><br></pre></td></tr></tbody></table></figure></li><li>在<code>kernel/syscall.c</code> 的<code>system_call</code> 中加入<code>sysinfo</code> <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *syscall_names[<span class="number">32</span>] = {<span class="string">""</span>, <span class="string">"fork"</span>, <span class="string">"exit"</span>, <span class="string">"wait"</span>, <span class="string">"pipe"</span>, <span class="string">"read"</span>, <span class="string">"kill"</span>, <span class="string">"exec"</span>, <span class="string">"fstat"</span>, <span class="string">"chdir"</span>, <span class="string">"dup"</span>, <span class="string">"getpid"</span>, <span class="string">"sbrk"</span>, <span class="string">"sleep"</span>, <span class="string">"uptime"</span>, <span class="string">"open"</span>, <span class="string">"write"</span>, <span class="string">"mknod"</span>, <span class="string">"unlink"</span>, <span class="string">"link"</span>, <span class="string">"mkdir"</span>, <span class="string">"close"</span>, <span class="string">"trace"</span>, <span class="string">"sysinfo"</span>};</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://raw.githubusercontent.com/leven-comeon/picture-club/main/202405071346710.png"></p>]]></content>
      
      
      <categories>
          
          <category> MIT </category>
          
          <category> 6.S081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab 1: Xv6 and Unix utilities</title>
      <link href="/2024/05/06/6.s081/utils/"/>
      <url>/2024/05/06/6.s081/utils/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-1-Xv6-and-Unix-utilities"><a href="#Lab-1-Xv6-and-Unix-utilities" class="headerlink" title="Lab 1: Xv6 and Unix utilities"></a>Lab 1: Xv6 and Unix utilities</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul><li>机器OS: <code>ubuntu 20.04</code></li><li>安装实验相关包:<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu </span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="一、启动-xv6（难度：easy）"><a href="#一、启动-xv6（难度：easy）" class="headerlink" title="一、启动 xv6（难度：easy）"></a>一、启动 xv6（难度：easy）</h2><ul><li><p>克隆<code>xv6</code> 代码并切换到<code>util</code> 分支</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021</span><br><span class="line">Cloning into <span class="string">'xv6-labs-2021'</span>...</span><br><span class="line">...</span><br><span class="line">$ <span class="built_in">cd</span> xv6-labs-2021</span><br><span class="line">$ git checkout util</span><br><span class="line">Branch <span class="string">'util'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'util'</span> from <span class="string">'origin'</span>.</span><br><span class="line">Switched to a new branch <span class="string">'util'</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>构建并运行xv6</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">riscv64-unknown-elf-gcc    -c -o kernel/entry.o kernel/entry.S</span><br><span class="line">riscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie   -c -o kernel/start.o kernel/start.c</span><br><span class="line">...  </span><br><span class="line">riscv64-unknown-elf-ld -z max-page-size=4096 -N -e main -Ttext 0 -o user/_zombie user/zombie.o user/ulib.o user/usys.o user/printf.o user/umalloc.o</span><br><span class="line">riscv64-unknown-elf-objdump -S user/_zombie &gt; user/zombie.asm</span><br><span class="line">riscv64-unknown-elf-objdump -t user/_zombie | sed <span class="string">'1,/SYMBOL TABLE/d; s/ .* / /; /^$/d'</span> &gt; user/zombie.sym</span><br><span class="line">mkfs/mkfs fs.img README  user/xargstest.sh user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie </span><br><span class="line">nmeta 46 (boot, super, <span class="built_in">log</span> blocks 30 inode blocks 13, bitmap blocks 1) blocks 954 total 1000</span><br><span class="line">balloc: first 591 blocks have been allocated</span><br><span class="line">balloc: write bitmap block at sector 45</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line"></span><br><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">init: starting sh</span><br><span class="line">$ </span><br></pre></td></tr></tbody></table></figure></li><li><p>使用<code>ls</code> 输出<code>mkfs</code> 在初始文件系统中包含的文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">.              1 1 1024</span><br><span class="line">..             1 1 1024</span><br><span class="line">README         2 2 2059</span><br><span class="line">xargstest.sh   2 3 93</span><br><span class="line"><span class="built_in">cat</span>            2 4 24256</span><br><span class="line"><span class="built_in">echo</span>           2 5 23080</span><br><span class="line">forktest       2 6 13272</span><br><span class="line">grep           2 7 27560</span><br><span class="line">init           2 8 23816</span><br><span class="line"><span class="built_in">kill</span>           2 9 23024</span><br><span class="line"><span class="built_in">ln</span>             2 10 22880</span><br><span class="line"><span class="built_in">ls</span>             2 11 26448</span><br><span class="line"><span class="built_in">mkdir</span>          2 12 23176</span><br><span class="line"><span class="built_in">rm</span>             2 13 23160</span><br><span class="line">sh             2 14 41976</span><br><span class="line">stressfs       2 15 24016</span><br><span class="line">usertests      2 16 148456</span><br><span class="line">grind          2 17 38144</span><br><span class="line"><span class="built_in">wc</span>             2 18 25344</span><br><span class="line">zombie         2 19 22408</span><br><span class="line">console        3 20 0</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用<code>ctrl-a x</code> 退出<code>qemu</code> ，<code>Ctrl-a</code> 按完松手再按<code>x</code> 退出</p></li></ul><h2 id="二、Sleep实现（难度：easy）"><a href="#二、Sleep实现（难度：easy）" class="headerlink" title="二、Sleep实现（难度：easy）"></a>二、Sleep实现（难度：easy）</h2><blockquote><p>实现xv6的UNIX程序sleep：您的sleep应该暂停到用户指定的计时数。一个滴答(tick)是由xv6内核定义的时间概念，即来自定时器芯片的两个中断之间的时间</p></blockquote><p>学习<code>main</code> 函数的两个参数<code>argc</code> 和<code>argv[]</code> 的含义，将参数传入<code>sleep</code> 系统调用即可实现相关功能。</p><ul><li><code>argc</code> 是命令行总的参数个数。</li><li><code>argv[]</code> 为保存命令行参数的字符串指针。其中第0个参数是程序的全名，以后的参数为命令行后面跟的用户输入的参数。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "user/sleep.cpp"</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) {</span><br><span class="line">        <span class="type">char</span> *msg = {<span class="string">"please input sleep time, usage: ./sleep &lt;number&gt;\n"</span>};</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">sleep</span>(t);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>Makefile</code> 中<code>UPROGS</code> 处添加<code>$U/_sleep\</code> </p><h2 id="三、pingpong实现（难度：easy）"><a href="#三、pingpong实现（难度：easy）" class="headerlink" title="三、pingpong实现（难度：easy）"></a>三、pingpong实现（难度：easy）</h2><blockquote><p>实现xv6的UNIX程序pingpong：编写一个程序，使用UNIX系统调用在一对管道上的两个进程之间 “ping-pong” 一个字节，每个方向一个。父级应该向子级发送一个字节; 子级应该打印 “&lt;pid&gt;: received ping”，其中 &lt;pid&gt; 是其进程ID，将管道上的字节写入父级，然后退出; 父级应该从子级读取字节，打印 “&lt;pid&gt;: received pong”，然后退出。</p></blockquote><p>学习管道的使用，通过使用<code>pipe</code> 系统调用来实现管道功能，通过<code>fork</code> 系统调用来实现子进程的创建。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "user/pingpong.cpp"</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_SIZE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READEND 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITEEND 1</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *msg_f = <span class="string">"ping"</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *msg_s = <span class="string">"pong"</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> buf[MSG_SIZE];</span><br><span class="line">    <span class="type">int</span> pf[<span class="number">2</span>], ps[<span class="number">2</span>];   <span class="comment">// 创建管道输入端口和输出端口</span></span><br><span class="line">    <span class="type">int</span> ppf = <span class="built_in">pipe</span>(pf);   <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="type">int</span> pps = <span class="built_in">pipe</span>(ps);</span><br><span class="line">    <span class="keyword">if</span>(ppf &lt; <span class="number">0</span> || pps &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) {  <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关闭父进程管道的写端口以及子进程管道的读端口</span></span><br><span class="line">        <span class="built_in">close</span>(ps[READEND]);</span><br><span class="line">        <span class="built_in">close</span>(pf[WRITEEND]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">read</span>(pf[READEND], buf, MSG_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: received %s\n"</span>, <span class="built_in">getpid</span>(), buf);</span><br><span class="line">        <span class="built_in">write</span>(ps[WRITEEND], msg_s, MSG_SIZE);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    } <span class="keyword">else</span> {        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">close</span>(ps[WRITEEND]);</span><br><span class="line">        <span class="built_in">close</span>(pf[READEND]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(pf[WRITEEND], msg_f, MSG_SIZE);</span><br><span class="line">        <span class="built_in">read</span>(ps[READEND], buf, MSG_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: received %s\n"</span>, <span class="built_in">getpid</span>(), buf);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>Makefile</code> 中<code>UPROGS</code> 处添加<code>$U/_pingpong\</code> </p><h2 id="四、Primes实现（难度：moderate-hard）"><a href="#四、Primes实现（难度：moderate-hard）" class="headerlink" title="四、Primes实现（难度：moderate/hard）"></a>四、Primes实现（难度：moderate/hard）</h2><blockquote><p>使用管道编写prime sieve(筛选素数)的并发版本。</p></blockquote><ul><li>由于一个数的因数一定比该数本身小，所以可以使用比当前数小的所有素数进行筛选</li><li>如果当前数不是已确定的所有素数的倍数，则该数为素数</li><li>若该数为素数，则以该数为基创建子进程，并和与该数最接近的素数建立管道</li><li>对每个数都使用串联的所有素数进行判断，直到确定其为合数或素数</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "user/primes.cpp"</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READEND     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITEEND    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM     35</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prime</span><span class="params">(<span class="type">int</span> p[<span class="number">2</span>])</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">close</span>(p[WRITEEND]);</span><br><span class="line">    <span class="type">int</span> base;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">read</span>(p[READEND], &amp;base, <span class="built_in">sizeof</span>(<span class="type">int</span>))) {   <span class="comment">// 读取传来的数据</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"prime %d\n"</span>, base);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pr[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">pipe</span>(pr);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">prime</span>(pr);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">close</span>(pr[READEND]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">read</span>(p[READEND], &amp;num, <span class="built_in">sizeof</span>(<span class="type">int</span>))) {</span><br><span class="line">            <span class="keyword">if</span>(num % base != <span class="number">0</span>) {</span><br><span class="line">                <span class="built_in">write</span>(pr[WRITEEND], &amp;num, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">close</span>(pr[WRITEEND]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(p[READEND]);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> left;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pipe</span>(p);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">prime</span>(p);</span><br><span class="line">    } <span class="keyword">else</span> {    <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">close</span>(READEND);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAX_NUM; i++) {</span><br><span class="line">            left = i;</span><br><span class="line">            <span class="built_in">write</span>(p[WRITEEND], &amp;left, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">close</span>(p[WRITEEND]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>Makefile</code> 中<code>UPROGS</code> 处添加<code>$U/_primes\</code> </p><h2 id="五、find实现（难度：Moderate）"><a href="#五、find实现（难度：Moderate）" class="headerlink" title="五、find实现（难度：Moderate）"></a>五、find实现（难度：Moderate）</h2><blockquote><p>写一个简化版本的UNIX的find程序：查找目录树中具有特定名称的所有文件</p></blockquote><p>学习<code>ls</code> 的实现逻辑，遍历目录树，寻找指定的文件名即可。</p><ul><li>注意：处理目录树中的两个特殊文件<code>"."</code> 和<code>".."</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "user/find.cpp"</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/fs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ + <span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find first character after last slash.</span></span><br><span class="line">    <span class="keyword">for</span> (p = path + <span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">'/'</span>; p--)</span><br><span class="line">        ;</span><br><span class="line">    p++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return blank-padded name.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="built_in">memmove</span>(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    <span class="built_in">memset</span>(buf + <span class="built_in">strlen</span>(p), <span class="number">0</span>, DIRSIZ - <span class="built_in">strlen</span>(p));</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span> de;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"find: cannot open %s\n"</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fstat</span>(fd, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"find: cannot stat %s\n"</span>, path);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st.type)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> T_FILE:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="built_in">fmtname</span>(path), filename) == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, path);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> T_DIR:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"find: path too long\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">        p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">        *p++ = <span class="string">'/'</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">read</span>(fd, &amp;de, <span class="built_in">sizeof</span>(de)) == <span class="built_in">sizeof</span>(de))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (de.inum == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">memmove</span>(p, de.name, DIRSIZ);</span><br><span class="line">            p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">stat</span>(buf, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"find: cannot stat %s\n"</span>, buf);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, <span class="string">"."</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">".."</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">find</span>(buf, filename);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: find &lt;path&gt; &lt;filename&gt;\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">find</span>(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>Makefile</code> 中<code>UPROGS</code> 处添加<code>$U/_find\</code> </p><h2 id="六、xargs实现（难度：Moderate）"><a href="#六、xargs实现（难度：Moderate）" class="headerlink" title="六、xargs实现（难度：Moderate）"></a>六、xargs实现（难度：Moderate）</h2><blockquote><p>编写一个简化版UNIX的xargs程序：它从标准输入中按行读取，并且为每一行执行一个命令，将行作为参数提供给命令。</p></blockquote><p>这个题目在第一次做的时候还是很难理解的，主要是参考了<a href="https://zhuanlan.zhihu.com/p/669622915">这篇文章</a></p><h3 id="1、xargs的作用"><a href="#1、xargs的作用" class="headerlink" title="1、xargs的作用"></a>1、xargs的作用</h3><p>我们知道管道<code>(pipe)</code> 是将前一个进程的输出<code>(stdout)</code> 作为下一下进程的输入<code>(stdin)</code> ，但是管道命令仅能处理<code>standard output</code> ，也就是说类似<code>less</code> 、<code>head</code> 、<code>tail</code> 等可以接受标准输入的命令。</p><p>而有很多命令不接收管道的传递方式，比如<code>ls</code> 和<code>echo</code> ，它们不能直接接收标准输入，而需要接收命令行参数，这时候就需要使用<code>xargs</code> 命令将管道传输过来的<code>stdin</code> 进行处理然后传递到命令的参数位上。也就是说，<code>xargs</code> 在这里执行了两个行为:</p><ul><li>处理管道左侧的标准输入</li><li>处理后传递到正确的位置上</li></ul><p>例如 <code>echo "one two three" | xargs mkdir</code> 等价于执行 <code>mkdir one two three</code> ，如果不加 <code>xargs</code> 则会提示 <code>mkdir</code> 缺少操作参数。</p><h3 id="2、实现思路"><a href="#2、实现思路" class="headerlink" title="2、实现思路"></a>2、实现思路</h3><p>事实上，就是从标准输入中读取字符串，直到遇到 <code>\n</code> 或 <code>\r</code> 则完成一次输入， 然后将所有的参数都读进来放在一个字符串数组里，然后将每一行都作为一个参数 <code>fork</code> 出一个子进程来执行 <code>exec</code> 系统调用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/xargs.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/param.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mygets</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i + <span class="number">1</span> &lt; max; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> cc = <span class="built_in">read</span>(<span class="number">0</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (cc &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">' '</span> || c == <span class="string">'\n'</span> || c == <span class="string">'\r'</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        buf[i] = c;</span><br><span class="line">    }</span><br><span class="line">    buf[i] = <span class="string">'\0'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getcmd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> nbuf)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, nbuf);</span><br><span class="line">    <span class="built_in">mygets</span>(buf, nbuf);</span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// EOF标志位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"Usage: xargs &lt;command&gt;\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">char</span> *_argv[MAXARG];</span><br><span class="line">    <span class="type">int</span> _argc = argc - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _argc; i++)</span><br><span class="line">    {</span><br><span class="line">        _argv[i] = argv[i + <span class="number">1</span>]; <span class="comment">// 构造新命令参数，排除 "xargs" 这个字符串</span></span><br><span class="line">    }</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getcmd</span>(buf, <span class="built_in">sizeof</span>(buf)) != <span class="number">-1</span>)  <span class="comment">// 读取标准输入中的字符串，即其他命令执行的结果</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            _argv[_argc] = buf;</span><br><span class="line">            _argc++;</span><br><span class="line">            <span class="built_in">exec</span>(argv[<span class="number">1</span>], _argv);   <span class="comment">// argv[1] 为 xargs 要执行的命令</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"exec %s failed\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>Makefile</code> 中<code>UPROGS</code> 处添加<code>$U/_xargs\</code> </p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://raw.githubusercontent.com/Leven-comeon/picture-club/main/Lab1-Utils.png"></p>]]></content>
      
      
      <categories>
          
          <category> MIT </category>
          
          <category> 6.S081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列解题总结</title>
      <link href="/2024/04/29/dai-ma-sui-xiang-lu/zhan-he-dui-lie-jie-ti-zong-jie/"/>
      <url>/2024/04/29/dai-ma-sui-xiang-lu/zhan-he-dui-lie-jie-ti-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="栈经典题目"><a href="#栈经典题目" class="headerlink" title="栈经典题目"></a>栈经典题目</h2><h3 id="栈在系统中的应用"><a href="#栈在系统中的应用" class="headerlink" title="栈在系统中的应用"></a>栈在系统中的应用</h3>]]></content>
      
      
      <categories>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈和队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表解题总结</title>
      <link href="/2024/04/29/dai-ma-sui-xiang-lu/ha-xi-biao-jie-ti-zong-jie/"/>
      <url>/2024/04/29/dai-ma-sui-xiang-lu/ha-xi-biao-jie-ti-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希表经典题目"><a href="#哈希表经典题目" class="headerlink" title="哈希表经典题目"></a>哈希表经典题目</h2><h3 id="数组作为哈希表"><a href="#数组作为哈希表" class="headerlink" title="数组作为哈希表"></a>数组作为哈希表</h3><p>一些应用场景就是为数组量身定做的。</p><p>在<code>有效的字母异位词</code>中，我们提到了数组就是简单的哈希表，但是数组的大小是受限的！这道题目包含小写字母，那么使用数组来做哈希最合适不过。</p><p>在<code>赎金信</code>中同样要求只有小写字母，那么就给我们浓浓的暗示，用数组！本题和 有效的字母异位词 很像，有效的字母异位词 是求 字符串a 和 字符串b 是否可以相互组成，在 赎金信 中是求字符串a能否组成字符串b，而不用管 字符串b 能不能组成 字符串a。</p><p>上面两道题目用map确实可以，但使用map的空间消耗要比数组大一些，因为map要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效！</p><h3 id="set作为哈希表"><a href="#set作为哈希表" class="headerlink" title="set作为哈希表"></a>set作为哈希表</h3><p>在<code>两个数组的交集</code>中我们给出了什么时候用数组就不行了，需要用set。这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p><p>主要因为如下两点：</p><ul><li>数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。</li><li>如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。所以此时一样的做映射的话，就可以使用set了。</li></ul><p>关于set，C++ 给提供了如下三种可用的数据结构：</p><ul><li>std::set</li><li>std::multiset</li><li>std::unordered_set</li></ul><p>std::set 和 std::multiset 底层实现都是红黑树，std::unordered_set 的底层实现是哈希，使用 unordered_set 读写效率是最高的，本题并不需要对数据进行排序，而且还不要让数据重复，所以选择 unordered_set。</p><p>在<code>快乐数</code>中，我们再次使用了 unordered_set 来判断一个数是否重复出现过。</p><h3 id="map作为哈希表"><a href="#map作为哈希表" class="headerlink" title="map作为哈希表"></a>map作为哈希表</h3><p>在<code>两数之和</code>中map正式登场。</p><p>来说一说：使用数组和set来做哈希法的局限。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li><li>map是一种&lt;key, value&gt;的结构，本题可以用key保存数值，用value在保存数值所在的下标。所以使用map最为合适。</li></ul><p>C++提供如下三种map：</p><ul><li>std::map</li><li>std::multimap</li><li>std::unordered_map</li></ul><p>std::unordered_map 底层实现为哈希，std::map 和std::multimap 的底层实现是红黑树。</p><p>同理，std::map 和 std::multimap 的 key 也是有序的，两数之和 中并不需要key有序，选择 std::unordered_map 效率更高！</p><p>在<code>四数相加 II</code>中我们提到了其实需要哈希的地方都能找到map的身影。</p><p>本题咋眼一看好像和 四数之和，三数之和 差不多，其实差很多！</p><p>关键差别是本题为四个独立的数组，只要找到 A[i] + B[j] + C[k] + D[l] &#x3D; 0 就可以，不用考虑重复问题，而 四数之和，三数之和 是一个数组（集合）里找到和为0的组合，可就难很多了！</p><p>用哈希法解决了两数之和，很多同学会感觉用哈希法也可以解决 三数之和，四数之和。</p><p>其实是可以解决，但是非常麻烦，需要去重导致代码效率很低。</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>在<code>三数之和</code>中我给出了 双指针 解法，大家就可以体会到，使用哈希法还是比较麻烦的。</p><p>所以 四数之和，三数之和 都推荐使用双指针法！</p>]]></content>
      
      
      <categories>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串解题总结</title>
      <link href="/2024/04/29/dai-ma-sui-xiang-lu/zi-fu-chuan-jie-ti-zong-jie/"/>
      <url>/2024/04/29/dai-ma-sui-xiang-lu/zi-fu-chuan-jie-ti-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串经典题目"><a href="#字符串经典题目" class="headerlink" title="字符串经典题目"></a>字符串经典题目</h2><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>在<code>反转字符串</code>，我们使用双指针法实现了反转字符串的操作，双指针法在数组，链表和字符串中很常用。</p><p>接着在字符串：<code>替换数字</code>，同样还是使用双指针法在时间复杂度$O(n)$的情况下完成替换空格。</p><p>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</p><p>那么针对数组删除操作的问题，其实在<code>移除元素</code>中就已经提到了使用双指针法进行移除操作。</p><p>同样的道理在<code>翻转字符串中的单词</code>中我们使用$O(n)$的时间复杂度，完成了删除冗余空格。</p><h3 id="反转系列"><a href="#反转系列" class="headerlink" title="反转系列"></a>反转系列</h3><p>在反转上还可以在加一些玩法，其实考察的是对代码的掌控能力。</p><p><code>反转字符串II</code>中，一些同学可能为了处理逻辑：每隔2k个字符的前k的字符，写了一堆逻辑代码或者再搞一个计数器，来统计2k，再统计前k个字符。其实当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。只要让 i +&#x3D; (2 * k) ，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。因为要找的也就是每2 * k 区间的起点，这样写程序会高效很多。</p><p>在<code>翻转字符串里的单词</code>中要求翻转字符串里的单词，这道题目可以说是综合考察了字符串的多种操作。是考察字符串的好题。这道题目通过 先整体反转再局部反转，实现了反转字符串里的单词。</p><p>后来发现反转字符串还有一个牛逼的用处，就是达到左旋的效果。在<code>右旋字符串</code>中，我们通过先局部反转再整体反转达到了左旋的效果。</p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</p><p>KMP的精髓所在就是前缀表，在<code>实现strStr()</code>中提到了，什么是KMP，什么是前缀表，以及为什么要用前缀表。</p><ul><li>前缀表：起始位置到下标i之前（包括i）的子串中，有多大长度的相同前缀后缀。</li></ul><p>那么使用KMP可以解决两类经典问题：</p><p>匹配问题：<code>实现 strStr()</code><br>重复子串问题：<code>重复的子字符串</code><br>再一次强调了什么是前缀，什么是后缀，什么又是最长相等前后缀。</p><ul><li>前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。</li><li>后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串。</li></ul><p>其中主要理解 j&#x3D;next[x] 这一步最为关键！</p>]]></content>
      
      
      <categories>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组解题总结</title>
      <link href="/2024/04/29/dai-ma-sui-xiang-lu/shu-zu-jie-ti-zong-jie/"/>
      <url>/2024/04/29/dai-ma-sui-xiang-lu/shu-zu-jie-ti-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="数组的经典题目"><a href="#数组的经典题目" class="headerlink" title="数组的经典题目"></a>数组的经典题目</h2><p>在面试中，数组是必考的基础数据结构。</p><p>其实数组的题目在思想上一般比较简单的，但是如果想高效，并不容易。</p><p>之前一共讲解了四种经典数组题目，每一种题目都代表一个类型，一种思想。</p><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p><strong>第一道题目是二分法题目</strong></p><p>这道题目呢，考察数组的基本操作，思路很简单，但是通过率在简单题里并不高，不要轻敌。</p><p>可以使用暴力解法，通过这道题目，如果追求更优的算法，建议试一试用二分法，来解决这道题目</p><ul><li>暴力解法时间复杂度：$O(n)$ </li><li>二分法时间复杂度：$O(logn)$</li></ul><p>在这道题目中我们讲到了循环不变量原则，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。</p><p>二分法是算法面试中的常考题，建议通过这道题目，锻炼自己手撕二分的能力。</p><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p><strong>第二道题目和第三道题目都是双指针法，第二道使用快慢指针法，第三道使用高低指针法</strong></p><ol><li>双指针法（快慢指针法）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</li></ol><ul><li>暴力解法时间复杂度：$O(n^2)$</li><li>双指针时间复杂度：$O(n)$</li></ul><p>这道题目迷惑了不少同学，纠结于数组中的元素为什么不能删除，主要是因为以下两点：</p><ul><li>数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。</li><li>C++中vector和array的区别一定要弄清楚，vector的底层实现是array，封装后使用更友好。</li></ul><p>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。</p><ol start="2"><li>双指针法（高低指针法）：通过一个从头开始的指针和一个从尾开始的指针，对向移动，在一个for循环下完成两个for循环的工作。</li></ol><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><strong>第四道题目是滑动窗口法</strong></p><ul><li>暴力解法时间复杂度：$O(n^2)$</li><li>滑动窗口时间复杂度：$O(n)$</li></ul><p>主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。</p><p>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将$O(n^2)$的暴力解法降为$O(n)$。</p><p>如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。</p><h3 id="模拟行为"><a href="#模拟行为" class="headerlink" title="模拟行为"></a>模拟行为</h3><p><strong>第五道题目是模拟题</strong></p><p>模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，十分考察对代码的掌控能力。</p><p>在这道题目中，我们再一次介绍到了<strong>循环不变量原则</strong>，其实这也是写程序中的重要原则。</p><p>相信大家有遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，拆了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实<strong>真正解决题目的代码都是简洁的，或者有原则性的</strong>，大家可以在这道题目中体会到这一点。</p>]]></content>
      
      
      <categories>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
